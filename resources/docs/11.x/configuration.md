# Конфігурація

- [Вступ](#introduction)
- [Конфігурація середовища](#environment-configuration)
    - [Типи змінних середовища](#environment-variable-types)
    - [Отримання конфігурації середовища](#retrieving-environment-configuration)
    - [Визначення поточного середовища](#determining-the-current-environment)
    - [Шифрування файлів оточення](#encrypting-environment-files)
- [Доступ до значень конфігурації](#accessing-configuration-values)
- [Кешування конфігурації](#configuration-caching)
- [Публікація конфігурації](#configuration-publishing)
- [Режим налагодження](#debug-mode)
- [Режим обслуговування](#maintenance-mode)

<a name="introduction"></a>
## Вступ

Всі конфігураційні файли для фреймворку Laravel зберігаються в каталозі `config`. Кожна опція задокументована, тому не соромтеся переглядати файли і знайомитися з доступними вам опціями.

Ці конфігураційні файли дозволяють вам налаштувати такі речі, як інформація про з'єднання з базою даних, інформація про поштовий сервер, а також різні інші основні значення конфігурації, такі як часовий пояс програми і ключ шифрування.

<a name="the-about-command"></a>
#### Про Командування

Laravel може показати огляд конфігурації, драйверів та оточення вашої програми за допомогою команди `about` Artisan.

```shell
php artisan about
```

Якщо вас цікавить лише певний розділ звіту, ви можете відфільтрувати цей розділ за допомогою опції `--only`:

```shell
php artisan about --only=environment
```

Або, щоб детально вивчити значення певного конфігураційного файлу, ви можете скористатися командою `config:show` Artisan:

```shell
php artisan config:show database
```

<a name="environment-configuration"></a>
## Конфігурація середовища

Часто буває корисно мати різні значення конфігурації залежно від середовища, в якому працює програма. Наприклад, ви можете використовувати інший драйвер кешу локально, ніж на робочому сервері.

Щоб зробити це простіше простого, Laravel використовує [DotEnv](https://github.com/vlucas/phpdotenv) Бібліотека PHP. При свіжому встановленні Laravel, кореневий каталог вашого додатку буде містити файл `.env.example`, який визначає багато загальних змінних оточення. Під час встановлення Laravel цей файл буде автоматично скопійовано до каталогу `.env`.

Стандартний файл `.env` Laravel містить деякі загальні конфігураційні значення, які можуть відрізнятися залежно від того, чи працює ваш додаток локально, чи на виробничому веб-сервері. Ці значення потім зчитуються конфігураційними файлами в каталозі `config` за допомогою функції `env` Laravel.

Якщо ви розробляєте у команді, ви можете продовжувати включати та оновлювати файл `.env.example` до вашої програми. Вставивши значення-заповнювачі у конфігураційний файл прикладу, інші розробники у вашій команді зможуть чітко бачити, які змінні оточення потрібні для запуску вашої програми.

> [!NOTE]
> Будь-яка змінна у вашому файлі `.env` може бути перевизначена зовнішніми змінними оточення, такими як змінні оточення на рівні сервера або системи.

<a name="environment-file-security"></a>
#### Безпека файлів навколишнього середовища

Ваш файл `.env` не повинен бути прив'язаним до контролю вихідного коду вашої програми, оскільки кожному розробнику/серверу, що використовує вашу програму, може знадобитися інша конфігурація середовища. Крім того, це буде ризиком для безпеки у випадку, якщо зловмисник отримає доступ до вашого сховища контролю вихідного коду, оскільки будь-які конфіденційні облікові дані стануть доступними.

Втім, ви можете зашифрувати файл оточення за допомогою вбудованого в Laravel [шифрування оточення](#шифрування-файлів-оточення). Зашифровані файли оточення можна безпечно розміщувати у контролі коду.

<a name="additional-environment-files"></a>
#### Додаткові файли оточення

Перед завантаженням змінних оточення вашої програми Laravel визначає, чи була надана змінна оточення `APP_ENV` ззовні, або чи був вказаний аргумент `--env` CLI. Якщо так, то Laravel спробує завантажити файл `.env.[APP_ENV]`, якщо він існує. Якщо його не існує, буде завантажено файл за замовчуванням `.env`.

<a name="environment-variable-types"></a>
### Типи змінних середовища

Усі змінні у ваших `.env`-файлах зазвичай розбираються як рядки, тому було створено деякі зарезервовані значення, щоб ви могли повертати ширший діапазон типів з функції `env()`:

| `.env` Value | `env()` Value |
|--------------|---------------|
| true         | (bool) true   |
| (true)       | (bool) true   |
| false        | (bool) false  |
| (false)      | (bool) false  |
| empty        | (string) ''   |
| (empty)      | (string) ''   |
| null         | (null) null   |
| (null)       | (null) null   |

Якщо вам потрібно визначити змінну оточення зі значенням, що містить пробіли, ви можете зробити це, взявши значення у подвійні лапки:

```ini
APP_NAME="My Application"
```

<a name="retrieving-environment-configuration"></a>
### Отримання конфігурації середовища

Усі змінні, перелічені у файлі `.env`, будуть завантажені у суперглобальну PHP-змінну `$_ENV`, коли ваша програма отримає запит. Однак ви можете використовувати функцію `env` для отримання значень цих змінних у ваших конфігураційних файлах. Насправді, якщо ви переглянете конфігураційні файли Laravel, ви помітите, що багато опцій вже використовують цю функцію:

    'debug' => env('APP_DEBUG', false),

Друге значення, що передається у функцію `env` - це «значення за замовчуванням». Це значення буде повернуто, якщо для даного ключа не існує змінної оточення.

<a name="determining-the-current-environment"></a>
### Визначення поточного середовища

Поточне середовище програми визначається за допомогою змінної `APP_ENV` з вашого файлу `.env`. Ви можете отримати доступ до цього значення через метод `environment` в `App`. [facade](/docs/{{version}}/facades):

    use Illuminate\Support\Facades\App;

    $environment = App::environment();

Ви також можете передати аргументи методу `environment`, щоб визначити, чи відповідає середовище заданому значенню. Метод поверне значення `true`, якщо оточення відповідає будь-якому із заданих значень:

    if (App::environment('local')) {
        // Навколишнє середовище локальне
    }

    if (App::environment(['local', 'staging'])) {
        // Середовище або локальне, або постановочне...
    }

> [!NOTE]  
> Виявлення поточного середовища програми можна змінити, визначивши змінну оточення на рівні сервера `APP_ENV`.

<a name="encrypting-environment-files"></a>
### Шифрування файлів оточення

Незашифровані файли оточення ніколи не слід зберігати у контролі коду. Однак Laravel дозволяє вам зашифрувати файли оточення, щоб їх можна було безпечно додавати до контролю коду разом з рештою вашої програми.

<a name="encryption"></a>
#### Шифрування

Щоб зашифрувати файл оточення, ви можете скористатися командою `env:encrypt`:

```shell
php artisan env:encrypt
```

Запуск команди `env:encrypt` зашифрує ваш файл `.env` і помістить зашифрований вміст у файл `.env.encrypted`. Ключ для розшифрування буде надано у результатах виконання команди, і його слід зберігати у надійному менеджері паролів. Якщо ви бажаєте надати власний ключ шифрування, ви можете скористатися опцією `--key` під час виклику команди:

```shell
php artisan env:encrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF
```

> [!NOTE]  
> Довжина наданого ключа повинна відповідати довжині ключа, що вимагається використовуваним шифром шифрування. За замовчуванням Laravel використовує шифр `AES-256-CBC`, який вимагає 32-символьний ключ. Ви можете використовувати будь-який шифр, що підтримується Laravel'ом [encrypter](/docs/{{version}}/encryption) передавши опцію `--cipher` при виклику команди.

Якщо ваша програма має декілька файлів оточення, наприклад, `.env` та `.env.staging`, ви можете вказати файл оточення, який слід зашифрувати, вказавши ім'я оточення за допомогою опції `--env`:

```shell
php artisan env:encrypt --env=staging
```

<a name="decryption"></a>
#### Розшифровка

Щоб розшифрувати файл оточення, ви можете скористатися командою `env:decrypt`. Ця команда вимагає ключ розшифрування, який Laravel отримає зі змінної оточення `LARAVEL_ENV_ENCRYPTION_KEY`:

```shell
php artisan env:decrypt
```

Або ж ключ можна передати безпосередньо команді за допомогою опції `--key`:

```shell
php artisan env:decrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF
```

Коли викликається команда `env:decrypt`, Laravel розшифровує вміст файлу `.env.encrypted` і поміщає розшифрований вміст у файл `.env`.

До команди `env:decrypt` можна додати опцію `--cipher`, щоб використовувати власний шифр шифрування:

```shell
php artisan env:decrypt --key=qUWuNRdfuImXcKxZ --cipher=AES-128-CBC
```

Якщо ваша програма має декілька файлів оточення, наприклад, `.env` та `.env.staging`, ви можете вказати файл оточення, який слід розшифрувати, вказавши ім'я оточення за допомогою опції `--env`:

```shell
php artisan env:decrypt --env=staging
```

Щоб перезаписати наявний файл оточення, ви можете додати опцію `--force` до команди `env:decrypt`:

```shell
php artisan env:decrypt --force
```

<a name="accessing-configuration-values"></a>
## Доступ до значень конфігурації

Ви можете легко отримати доступ до значень конфігурації за допомогою панелі `Config` або глобальної функції `config` з будь-якого місця вашої програми. Доступ до значень конфігурації можна отримати за допомогою «крапкового» синтаксису, який включає ім'я файлу та параметр, до якого ви хочете отримати доступ. Також можна вказати значення за замовчуванням, яке буде повернуто, якщо параметр конфігурації не існує:

    use Illuminate\Support\Facades\Config;

    $value = Config::get('app.timezone');

    $value = config('app.timezone');

    // Отримати значення за замовчуванням, якщо значення конфігурації не існує...
    $value = config('app.timezone', 'Asia/Seoul');

Щоб встановити значення конфігурації під час виконання, ви можете викликати метод `set` фасаду `Config` або передати масив у функцію `config`:

    Config::set('app.timezone', 'America/Chicago');

    config(['app.timezone' => 'America/Chicago']);

Для полегшення статичного аналізу фасад `Config` також надає типізовані методи пошуку конфігурації. Якщо знайдене значення конфігурації не відповідає очікуваному типу, буде згенеровано виключення:

    Config::string('config-key');
    Config::integer('config-key');
    Config::float('config-key');
    Config::boolean('config-key');
    Config::array('config-key');

<a name="configuration-caching"></a>
## Кешування конфігурації

Щоб прискорити роботу вашого додатку, вам слід кешувати всі конфігураційні файли в один файл за допомогою команди `config:cache` Artisan. Це об'єднає всі параметри конфігурації вашого додатку в один файл, який може бути швидко завантажений фреймворком.

Зазвичай вам слід запускати команду `php artisan config:cache` як частину процесу розгортання вашого продукту. Цю команду не слід запускати під час локальної розробки, оскільки параметри конфігурації часто потрібно буде змінювати під час розробки вашого додатку.

Після кешування конфігурації файл `.env` вашого додатку не буде завантажуватися фреймворком під час запитів або команд Artisan; отже, функція `env` повертатиме лише зовнішні змінні оточення системного рівня.

З цієї причини вам слід переконатися, що ви викликаєте функцію `env` лише з конфігураційних (`config`) файлів вашої програми. Ви можете побачити багато прикладів цього, переглянувши конфігураційні файли Laravel за замовчуванням. Доступ до конфігураційних значень можна отримати з будь-якого місця вашої програми за допомогою функції `config` [описані вище](#accessing-configuration-values).

Команда `config:clear` може бути використана для очищення кешованої конфігурації:

```shell
php artisan config:clear
```

> [!WARNING]  
> Якщо ви виконуєте команду `config:cache` під час процесу розгортання, вам слід переконатися, що ви викликаєте функцію `env` лише з ваших конфігураційних файлів. Після кешування конфігурації файл `.env` не буде завантажено; отже, функція `env` повертатиме лише зовнішні змінні оточення системного рівня.

<a name="configuration-publishing"></a>
## Публікація конфігурації

Більшість конфігураційних файлів Laravel вже опубліковані в каталозі `config` вашого додатку; однак деякі конфігураційні файли, такі як `cors.php` і `view.php`, не публікуються за замовчуванням, оскільки більшості додатків ніколи не знадобиться їх змінювати.

Втім, ви можете скористатися командою `config:publish` Artisan для публікації будь-яких конфігураційних файлів, які не публікуються за замовчуванням:

```shell
php artisan config:publish

php artisan config:publish --all
```

<a name="debug-mode"></a>
## Режим налагодження

Параметр `debug` у вашому файлі конфігурації `config/app.php` визначає, скільки інформації про помилку буде показано користувачеві. За замовчуванням ця опція встановлена на значення змінної оточення `APP_DEBUG`, яка зберігається у вашому файлі `.env`.

> [!WARNING]  
> Для локальної розробки вам слід встановити змінну оточення `APP_DEBUG` у значення `true`. **У вашому виробничому середовищі це значення завжди має бути `false`. Якщо ця змінна має значення `true` у виробничому середовищі, ви ризикуєте відкрити чутливі значення конфігурації для кінцевих користувачів вашого додатка.**

<a name="maintenance-mode"></a>
## Режим обслуговування

Коли ваш додаток знаходиться в режимі обслуговування, для всіх запитів до вашого додатку буде відображатися спеціальне подання. Це дозволяє легко «вимкнути» вашу програму під час її оновлення або виконання технічного обслуговування. Перевірка режиму обслуговування включена до стеку проміжного програмного забезпечення за замовчуванням для вашої програми. Якщо програма перебуває у режимі обслуговування, буде згенеровано екземпляр `Symfony\Component\HttpKernel\Exception\HttpException` з кодом стану 503.

Щоб увімкнути режим обслуговування, виконайте команду `down` Artisan:

```shell
php artisan down
```

Якщо ви хочете, щоб HTTP-заголовок `Refresh` надсилався з усіма відповідями режиму обслуговування, ви можете вказати опцію `refresh` під час виклику команди `down`. Заголовок `Refresh` дасть браузеру вказівку автоматично оновити сторінку через вказану кількість секунд:

```shell
php artisan down --refresh=15
```

Ви також можете додати до команди `down` опцію `retry`, яка буде встановлена як значення заголовка HTTP `Retry-After`, хоча браузери зазвичай ігнорують цей заголовок:

```shell
php artisan down --retry=60
```

<a name="bypassing-maintenance-mode"></a>
#### Обхід режиму технічного обслуговування

Щоб дозволити обхід режиму обслуговування за допомогою секретного токена, ви можете використати опцію `секретний`, щоб вказати токен для обходу режиму обслуговування:

```shell
php artisan down --secret="1630542a-246b-4b66-afa1-dd72a4c43515"
```

Після переведення програми в режим обслуговування ви можете перейти за URL-адресою програми, що відповідає цьому токену, і Laravel видасть вашому браузеру файл cookie для обходу режиму обслуговування:

```shell
https://example.com/1630542a-246b-4b66-afa1-dd72a4c43515
```

Якщо ви хочете, щоб Laravel згенерував секретний токен для вас, ви можете скористатися опцією `with-secret`. Секрет буде показано вам, як тільки програма перейде в режим обслуговування:

```shell
php artisan down --with-secret
```

При доступі до цього прихованого маршруту ви будете перенаправлені на маршрут `/` додатку. Після того, як файл cookie буде передано вашому браузеру, ви зможете переглядати додаток у звичайному режимі, як якщо б він не перебував у режимі обслуговування.

> [!NOTE]  
> Ваш секрет режиму обслуговування зазвичай має складатися з буквено-цифрових символів і, за бажанням, тире. Не слід використовувати символи, які мають особливе значення в URL-адресах, такі як `?` або `&`.

<a name="pre-rendering-the-maintenance-mode-view"></a>
#### Попередній перегляд подання режиму технічного обслуговування

Якщо ви використовуєте команду `php artisan down` під час розгортання, ваші користувачі все одно можуть іноді стикатися з помилками, якщо вони отримують доступ до програми під час оновлення залежностей Composer або інших компонентів інфраструктури. Це відбувається тому, що значна частина фреймворку Laravel повинна завантажитися, щоб визначити, що ваш додаток знаходиться в режимі обслуговування, і відобразити вигляд режиму обслуговування за допомогою механізму шаблонів.

З цієї причини Laravel дозволяє вам попередньо відрендерити представлення режиму обслуговування, яке буде повернуто на самому початку циклу запиту. Це подання відображається до того, як завантажиться будь-яка з залежностей вашого додатку. Ви можете попередньо відрендерити шаблон за вашим вибором за допомогою опції `render` команди `down`:

```shell
php artisan down --render="errors::503"
```

<a name="redirecting-maintenance-mode-requests"></a>
#### Перенаправлення запитів на режим технічного обслуговування

Перебуваючи в режимі обслуговування, Laravel відображатиме режим обслуговування для всіх URL-адрес додатків, до яких користувач намагається отримати доступ. Якщо ви бажаєте, ви можете наказати Laravel перенаправляти всі запити на певну URL-адресу. Це можна зробити за допомогою опції `redirect`. Наприклад, ви можете перенаправляти всі запити на `/` URI:

```shell
php artisan down --redirect=/
```

<a name="disabling-maintenance-mode"></a>
#### Вимкнення режиму обслуговування

Щоб вимкнути режим обслуговування, скористайтеся командою `up`:

```shell
php artisan up
```

> [!NOTE]  
> Ви можете налаштувати шаблон режиму обслуговування за замовчуванням, визначивши власний шаблон за адресою `resources/views/errors/503.blade.php`.

<a name="maintenance-mode-queues"></a>
#### Режим обслуговування та черги

Поки ваш додаток знаходиться в режимі технічного обслуговування, ні [завдання в черзі](/docs/{{version}}/queues) будуть оброблятися. Як тільки додаток вийде з режиму технічного обслуговування, завдання будуть оброблятися у звичайному режимі.

<a name="alternatives-to-maintenance-mode"></a>
#### Альтернативи режиму обслуговування

Оскільки режим технічного обслуговування вимагає від вашого додатка декількох секунд простою, розгляньте такі альтернативи, як [Laravel Vapor](https://vapor.laravel.com) та [Envoyer](https://envoyer.io) розгортання з нульовим часом простою за допомогою Laravel.
