# CSRF захист

- [Вступ](#csrf-introduction)
- [Запобігання запитам щодо CSRF](#preventing-csrf-requests)
    - [Без урахування URI](#csrf-excluding-uris)
- [X-CSRF-Token](#csrf-x-csrf-token)
- [X-XSRF-Token](#csrf-x-xsrf-token)

<a name="csrf-introduction"></a>
## Вступ

Підробка міжсайтових запитів - це тип шкідливого експлойту, за допомогою якого несанкціоновані команди виконуються від імені автентифікованого користувача. На щастя, Laravel дозволяє легко захистити ваш додаток від [підробки міжсайтових запитів](https://en.wikipedia.org/wiki/Cross-site_request_forgery) (CSRF) атаки.

<a name="csrf-explanation"></a>
#### Пояснення вразливості

Якщо ви не знайомі з міжсайтовими підробками запитів, давайте розглянемо приклад того, як ця уразливість може бути використана. Уявіть, що у вашому додатку є маршрут `/user/email`, який приймає `POST`-запит на зміну адреси електронної пошти автентифікованого користувача. Скоріш за все, цей маршрут очікує, що поле введення `email` буде містити адресу електронної пошти, яку користувач хотів би використовувати.

Без захисту CSRF шкідливий веб-сайт може створити HTML-форму, яка вказує на маршрут `/user/email` вашого додатку і відправляє власну адресу електронної пошти зловмисника:

```blade
<form action="https://your-application.com/user/email" method="POST">
    <input type="email" value="malicious-email@example.com">
</form>

<script>
    document.forms[0].submit();
</script>
```

Якщо шкідливий веб-сайт автоматично надсилає форму під час завантаження сторінки, зловмиснику потрібно лише заманити нічого не підозрюючого користувача вашого додатку на свій веб-сайт, і його адреса електронної пошти буде змінена у вашому додатку.

Щоб запобігти цій уразливості, потрібно перевіряти кожен вхідний запит `POST`, `PUT`, `PATCH` або `DELETE` на наявність секретного значення сеансу, до якого зловмисний додаток не зможе отримати доступ.

<a name="preventing-csrf-requests"></a>
## Запобігання запитам щодо CSRF

Laravel автоматично генерує «токен» CSRF для кожного активного [сеанс користувача](/docs/{{version}}/session) управляється додатком. Цей маркер використовується для перевірки того, що автентифікований користувач є особою, яка дійсно робить запити до програми. Оскільки цей маркер зберігається в сеансі користувача і змінюється щоразу, коли сеанс регенерується, зловмисний додаток не може отримати до нього доступ.

Доступ до CSRF-токену поточного сеансу можна отримати через сеанс запиту або за допомогою допоміжної функції `csrf_token`:

    use Illuminate\Http\Request;

    Route::get('/token', function (Request $request) {
        $token = $request->session()->token();

        $token = csrf_token();

        // ...
    });

Кожного разу, коли ви визначаєте HTML-форми «POST», «PUT», «PATCH» або «DELETE» у вашому додатку, ви повинні включити приховане поле CSRF `_token` у форму, щоб проміжне програмне забезпечення для захисту CSRF могло перевірити запит. Для зручності ви можете використовувати директиву `@csrf` Blade для створення поля введення прихованого токена:

```blade
<form method="POST" action="/profile">
    @csrf

    <!-- Equivalent to... -->
    <input type="hidden" name="_token" value="{{ csrf_token() }}" />
</form>
```

У `Illuminate\Foundation\Http\Middleware\ValidateCsrfToken` [middleware](/docs/{{version}}/middleware), який за замовчуванням включено до групи проміжного програмного забезпечення `web`, автоматично перевіряє відповідність токену у вхідних даних запиту токену, що зберігається у сеансі. Якщо ці два токени збігаються, ми знаємо, що саме автентифікований користувач є ініціатором запиту.

<a name="csrf-tokens-and-spas"></a>
### CSRF Tokens & SPAs

Якщо ви створюєте SPA, який використовує Laravel в якості бекенда API, вам слід звернутися до розділу [Laravel Sanctum documentation](/docs/{{version}}/sanctum) для отримання інформації про автентифікацію за допомогою вашого API та захист від CSRF-уразливостей.

<a name="csrf-excluding-uris"></a>
### Виключення URI з-під захисту CSRF

Іноді вам може знадобитися виключити набір URI з-під захисту CSRF. Наприклад, якщо ви використовуєте [Stripe](https://stripe.com) для обробки платежів і використовують їхню систему веб-хуків, вам потрібно буде виключити ваш маршрут обробника веб-хуків Stripe із захисту CSRF, оскільки Stripe не знатиме, який токен CSRF надсилати до ваших маршрутів.

Зазвичай такі маршрути слід розміщувати поза групою проміжного програмного забезпечення `web`, яку Laravel застосовує до всіх маршрутів у файлі `routes/web.php`. Однак ви також можете виключити певні маршрути, надавши їхні URI методу `validateCsrfTokens` у файлі `bootstrap/app.php` вашого додатку:

    ->withMiddleware(function (Middleware $middleware) {
        $middleware->validateCsrfTokens(except: [
            'stripe/*',
            'http://example.com/foo/bar',
            'http://example.com/foo/*',
        ]);
    })

> [!NOTE]  
> Для зручності проміжне програмне забезпечення CSRF автоматично відключається для всіх маршрутів, коли [запуск тестів](/docs/{{version}}/testing).

<a name="csrf-x-csrf-token"></a>
## X-CSRF-TOKEN

На додаток до перевірки маркера CSRF як параметра POST, проміжне програмне забезпечення `Illuminate\Foundation\Http\Middleware\ValidateCsrfToken`, яке за замовчуванням включено до групи проміжного програмного забезпечення `web`, також перевірить заголовок запиту `X-CSRF-TOKEN`. Ви можете, наприклад, зберігати токен у тезі `meta` HTML:

```blade
<meta name="csrf-token" content="{{ csrf_token() }}">
```

Потім ви можете наказати бібліотеці, наприклад, jQuery, автоматично додавати маркер до всіх заголовків запитів. Це забезпечує простий і зручний захист від CSRF для ваших AJAX-додатків, що використовують застарілу технологію JavaScript:

```js
$.ajaxSetup({
    headers: {
        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
});
```

<a name="csrf-x-xsrf-token"></a>
## X-XSRF-TOKEN

Laravel зберігає поточний CSRF-токен у зашифрованому файлі cookie `XSRF-TOKEN`, який додається до кожної відповіді, що генерується фреймворком. Ви можете використовувати значення cookie для встановлення заголовка запиту `X-XSRF-TOKEN`.

Цей файл cookie надсилається насамперед для зручності розробників, оскільки деякі фреймворки та бібліотеки JavaScript, такі як Angular і Axios, автоматично поміщають його значення в заголовок `X-XSRF-TOKEN` для запитів того ж походження.

> [!NOTE]  
> За замовчуванням, файл `resources/js/bootstrap.js` містить HTTP бібліотеку Axios, яка автоматично надішле вам заголовок `X-XSRF-TOKEN`.
