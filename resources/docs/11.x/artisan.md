# Artisan консоль

- [Вступ](#introduction)
    - [Laravel Sail](#laravel-sail)
    - [Tinker (REPL)](#tinker)
- [Написання команд](#writing-commands)
    - [Генерація команд](#generating-commands)
    - [Структура команди](#command-structure)
    - [Анонімні команди](#closure-commands)
    - [Ізольовані команди](#isolatable-commands)
- [Визначення даних, що вводяться](#defining-input-expectations)
    - [Аргументи](#arguments)
    - [Параметри](#options)
    - [Масиви даних](#input-arrays)
    - [Описи даних, що вводяться](#input-descriptions)
    - [Запит відсутнього введення](#prompting-for-missing-input)
- [Введення/виведення команди](#command-io)
    - [Отримання вхідних даних](#retrieving-input)
    - [Запит для введення даних](#prompting-for-input)
    - [Виведення даних](#writing-output)
- [Реєстрація команд](#registering-commands)
- [Програмне виконання команд](#programmatically-executing-commands)
    - [Виклик команд з інших команд](#calling-commands-from-other-commands)
- [Обробка сигналів](#signal-handling)
- [Налаштування заготовок команд (stubs)](#stub-customization)
- [Події](#events)

<a name="introduction"></a>
## Вступ

Artisan - це інтерфейс командного рядка, що входить до складу Laravel. Він пропонує низку корисних команд, які допоможуть при створенні програми. Для перегляду списку всіх доступних команд Artisan можна використовувати команду `list`:

```shell
php artisan list
```

Кожна команда також включає в себе екран «довідки», який відображає та описує доступні аргументи та параметри команди. Щоб переглянути екран довідки, використовуйте `help` перед іменем команди:

```shell
php artisan help migrate
```

<a name="laravel-sail"></a>
#### Laravel Sail

Якщо ви використовуєте [Laravel Sail](/docs/{{version}}}/sail) як локальне середовище розробки, не забудьте використати командний рядок `sail` для виклику команд Artisan. Sail виконає ваші команди Artisan у контейнерах Docker вашого додатка:

```shell
./vendor/bin/sail artisan list
```

<a name="tinker"></a>
### Tinker (REPL)

Laravel Tinker - це потужний REPL для фреймворку Laravel, заснований на пакеті [PsySH](https://github.com/bobthecow/psysh).

<a name="installation"></a>
#### Установка

Усі програми Laravel за замовчуванням включають Tinker. Однак ви можете встановити Tinker за допомогою Composer, якщо ви раніше видалили його зі своєї програми:

```shell
composer require laravel/tinker
```

> [!NOTE]
> Шукаєте графічний інтерфейс для взаємодії з додатком Laravel? Зацініть [Tinkerwell](https://tinkerwell.app)!

<a name="usage"></a>
#### Використання

Tinker дає змогу взаємодіяти повністю з усім додатком Laravel із командного рядка, включно з моделями Eloquent, завданнями, подіями та багато іншого. Щоб увійти в середовище Tinker, виконайте команду `tinker` Artisan:

```shell
php artisan tinker
```

Ви можете опублікувати конфігураційний файл Tinker за допомогою команди `vendor:publish`:

```shell
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"
```

> [!WARNING]
> Глобальний помічник `dispatch` і метод `dispatch` класу `Dispatchable` залежать від «garbage collection» для поміщення завдання в чергу. Отже, при використанні Tinker ви повинні використовувати `Bus::dispatch` або `Queue::push` для відправки завдань.

<a name="command-allow-list"></a>
#### Список дозволених команд

Tinker використовує список «дозволених» команд, які дозволено запускати Artisan в її середовищі. За замовчуванням ви можете запускати команди `clear-compiled`, `down`, `env`, `inspire`, `migrate`, `migrate:install`, `up` і `optimize`. Для додавання до цього списку більше команд, додайте їх у масив `commands` конфігураційного файлу `config/tinker.php`:

    'commands' => [
        // App\Console\Commands\ExampleCommand::class,
    ],

<a name="classes-that-should-not-be-aliased"></a>
#### Чорний список псевдонімів

Як правило, Tinker автоматично створює псевдоніми класів, коли ви взаємодієте з ними в Tinker. Проте ви можете заборонити таку поведінку для деяких класів, перерахувавши їх у масиві `dont_alias` конфігураційного файлу `config/tinker.php`:

    'dont_alias' => [
        App\Models\User::class,
    ],

<a name="writing-commands"></a>
## Написання команд

На додаток до команд Artisan, ви можете створювати користувацькі команди. Команди зазвичай зберігаються в каталозі `app/Console/Commands`; однак ви можете вибрати інше місце розташування, якщо ці команди можуть бути завантажені менеджером Composer.

<a name="generating-commands"></a>
### Генерація команд

Щоб згенерувати нову команду, використовуйте команду `make:command` [Artisan](artisan). Ця команда помістить новий клас команди в каталог `app/Console/Commands` вашого додатка. Якщо цей каталог не існує у вашому додатку, то Laravel попередньо створить його:

```shell
php artisan make:command SendEmails
```

<a name="command-structure"></a>
### Структура команди

Після створення команди слід заповнити властивості класу `$signature` і `$description`. Ці властивості відображатимуться на екрані під час використання команди `list`. Властивість `$signature` також дає змогу [визначати дані, що вводяться](#defining-input-expectations). Метод `handle` буде викликатися під час виконання команди. Ви можете розмістити логіку команди в цьому методі.

Давайте розглянемо приклад команди. Зверніть увагу, що ми можемо запросити будь-які необхідні залежності в методі `handle` команди. [Контейнер служб](/docs/{{version}}}/container) Laravel автоматично впровадить усі залежності, типи яких оголошені в цьому методі:

    <?php

    namespace App\Console\Commands;

    use App\Models\User;
    use App\Support\DripEmailer;
    use Illuminate\Console\Command;

    class SendEmails extends Command
    {
        /**
         * Ім'я та сигнатура консольної команди.
         *
         * @var string
         */
        protected $signature = 'mail:send {user}';

        /**
         * Опис консольної команди.
         *
         * @var string
         */
        protected $description = 'Send a marketing email to a user';


        /**
         * Виконати консольну команду.
         */
        public function handle(DripEmailer $drip): void
        {
            $drip->send(User::find($this->argument('user')));
        }
    }

> [!NOTE]
> Хорошою практикою повторного використання коду вважається створення «простих» консольних команд із делегуванням своїх завдань службам додатка. У наведеному прикладі ми впроваджуємо клас служби для виконання «витратного» надсилання електронних листів.

<a name="exit-codes"></a>
#### Коди завершення

Якщо з методу `handle` нічого не повертається і команда виконується успішно, команда завершиться з кодом завершення `0`, що вказує на успіх. Однак метод `handle` може додатково повертати ціле число, щоб вручну вказати код завершення команди:

    $this->error('Something went wrong.');

    return 1;

Якщо ви хочете «не виконати» команду будь-яким методом всередині команди, ви можете використовувати метод `fail`. Метод `fail` негайно припинить виконання команди і поверне код завершення `1`:

    $this->fail('Something went wrong.');

<a name="closure-commands"></a>
### Анонімні команди

Анонімні команди забезпечують альтернативу визначенню консольних команд у вигляді класів. Так само, як замикання маршрутів є альтернативою контролерам.

Незважаючи на те, що файл `routes/console.php` не визначає HTTP-маршрути, він визначає консольні точки входу (маршрути) у ваш додаток. У цьому файлі ви можете визначити всі консольні команди на основі замикань, використовуючи метод `Artisan::command`. Метод `command` приймає два аргументи: [сигнатура команди](#defining-input-expectations) і замикання, яке отримує аргументи та параметри команди:

    Artisan::command('mail:send {user}', function (string $user) {
        $this->info("Sending email to: {$user}!");
    });

Замикання прив'язане до базового екземпляра команди, тому у вас є повний доступ до всіх допоміжних методів, до яких ви зазвичай можете звертатися в команді, створеній за допомогою класу.

<a name="type-hinting-dependencies"></a>
#### Типізація залежностей

Крім отримання аргументів і параметрів, замикання анонімної команди також приймає додаткові залежності з [контейнера служб](/docs/{{version}}}/container), необхідні для впровадження:

    use App\Models\User;
    use App\Support\DripEmailer;

    Artisan::command('mail:send {user}', function (DripEmailer $drip, string $user) {
        $drip->send(User::find($user));
    });

<a name="closure-command-descriptions"></a>
#### Описи анонімних команд

При визначенні анонімних команд, можна використовувати метод `purpose` для додавання опису команди. Цей опис відображатиметься під час запуску команд `phprop artisan list` і `phprop artisan help`:

    Artisan::command('mail:send {user}', function (string $user) {
        // ...
    })->purpose('Send a marketing email to a user');

<a name="isolatable-commands"></a>
### Ізольовані команди

> [!WARNING]
> Для використання цієї функції ваш додаток повинен використовувати `memcached`, `redis`, `dynamodb`, `database`, `file` або `array` як кеш-драйвер за замовчуванням. Крім того, всі сервери повинні обмінюватися даними з одним і тим самим центральним сервером кешу.

Іноді вам може знадобитися, щоб одночасно міг виконуватися тільки один екземпляр команди. Для цього ви можете реалізувати інтерфейс `Illuminate\Contracts\Console\Isolatable` у вашому класі команди:

     <?php
    
    namespace App\Console\Commands;

    use Illuminate\Console\Command;
    use Illuminate\Contracts\Console\Isolatable;

    class SendEmails extends Command implements Isolatable
    {
        // ...
    }


Коли команда позначена як `Isolatable`, Laravel автоматично додасть опцію `--isolated` до команди. Коли команда викликається з цією опцією, Laravel гарантує, що жоден інший екземпляр цієї команди в даний момент не виконується. Laravel досягає цього, намагаючись отримати блокування за допомогою кеш-драйвера за замовчуванням вашого додатка. Якщо інші екземпляри команди виконуються, команда не буде виконана; однак команда все одно завершиться з кодом успішного завершення:

```shell
php artisan mail:send 1 --isolated
```

Якщо ви хочете вказати код статусу завершення, який команда повинна повернути, якщо вона не може виконатися, ви можете надати його за допомогою опції `isolated`:

```shell
php artisan mail:send 1 --isolated=12
```

<a name="lock-id"></a>
#### Ідентифікатор блокування (Lock ID)

За замовчуванням Laravel використовує ім'я команди для генерації рядкового ключа, який використовується для отримання блокування в кеші вашої програми. Однак ви можете налаштувати цей ключ, визначивши метод `isolatableId` у вашому класі команди Artisan, що дає змогу інтегрувати аргументи або опції команди в ключ:

```php
/**
 * Отримайте ізольований ідентифікатор для команди.
 */
public function isolatableId(): string
{
    return $this->argument('user');
}
```

<a name="lock-expiration-time"></a>
#### Термін дії блокування

За замовчуванням ізоляційні блокування закінчуються після завершення команди. Або, якщо команда перервана і не може бути завершена, термін дії блокування закінчиться через одну годину. Однак ви можете налаштувати час дії блокування, визначивши метод `isolationLockExpiresAt` у вашій команді:

```php
use DateTimeInterface;
use DateInterval;

/**
 * Визначити, коли закінчується термін дії блокування ізоляції для команди.
 */
public function isolationLockExpiresAt(): DateTimeInterface|DateInterval
{
    return now()->addMinutes(5);
}
```

<a name="defining-input-expectations"></a>
## Визначення даних, що вводяться

Під час написання консольних команд зазвичай відбувається збір даних, одержуваних від користувача, за допомогою аргументів або параметрів. Laravel дозволяє дуже зручно визначати вхідні дані, які ви очікуєте від користувача, використовуючи властивість `$signature` команди. Властивість `$signature` дає змогу визначити ім'я, аргументи та параметри команди в єдиному виразному синтаксисі, схожому із синтаксисом маршрутів.

<a name="arguments"></a>
### Аргументи

Усі надані користувачем аргументи та параметри укладаються у фігурні дужки. У наступному прикладі команда визначає один обов'язковий аргумент `user`:

    /**
     * Ім'я та сигнатура консольної команди.
     *
     * @var string
     */
    protected $signature = 'mail:send {user}';

За бажанням можна зробити аргументи необов'язковими або визначити значення за замовчуванням:

    // Необов'язковий аргумент ...
    'mail:send {user?}'

    // Необов'язковий аргумент із заданим за замовчуванням значенням ...
    'mail:send {user=foo}'

<a name="options"></a>
### Параметри

Параметри, як і аргументи, є різновидом користувацького введення. Параметри повинні мати префікс у вигляді двох дефісів (`--`), при використанні їх у командному рядку. Існує два типи параметрів: ті, що отримують значення, і ті, які його не отримують. Параметри, які не отримують значення, слугують логічними «перемикачами». Давайте розглянемо приклад такого варіанту:

    /**
     * Ім'я та сигнатура консольної команди.
     *
     * @var string
     */
    protected $signature = 'mail:send {user} {--queue}';

У цьому прикладі під час виклику команди Artisan може бути вказано перемикач `--queue`. Якщо перемикач `--queue` передано, то значення цього параметра буде `true`. В іншому випадку значення буде `false`:

```shell
php artisan mail:send 1 --queue
```

<a name="options-with-values"></a>
#### Параметри зі значеннями

Давайте розглянемо параметр, який очікує значення. Якщо користувач повинен вказати значення для параметра, то додайте суфікс `=` до імені параметра:

    /**
     * Ім'я та сигнатура консольної команди.
     *
     * @var string
     */
    protected $signature = 'mail:send {user} {--queue=}';

У цьому прикладі користувач може передати значення для параметра. Якщо параметр не вказано під час виклику команди, то його значення буде `null`:

```shell
php artisan mail:send 1 --queue=default
```

Параметру можна присвоїти значення за замовчуванням, вказавши його після імені. Якщо значення параметра не передано користувачем, то буде використано значення за замовчуванням:

    'mail:send {user} {--queue=default}'

<a name="option-shortcuts"></a>
#### Псевдоніми параметрів

Щоб призначити псевдонім під час визначення параметра, ви можете вказати його перед ім'ям параметра та використати символ роздільника `|` для відокремлення псевдоніма від повного імені параметра:

    'mail:send {user} {--Q|queue}'

Під час виклику команди в терміналі, псевдоніми параметрів повинні мати префікс з одним дефісом, і символ `=` не повинен використовуватися під час зазначення значення параметра:

```shell
php artisan mail:send 1 -Qdefault
```

<a name="input-arrays"></a>
### Масиви даних

Щоб визначити, що аргументи або параметри очікують масив даних, використовуйте метасимвол `*`. По-перше, давайте розглянемо приклад, у якому описується аргумент як масив даних:

    'mail:send {user*}'

При виклику цього методу аргументи `user` можуть передаватися по порядку в командний рядок. Наприклад, наступна команда встановить значення `user` як `1` і `2`:

```shell
php artisan mail:send 1 2
```

Метасимвол `*` можна комбінувати з необов'язковим визначенням аргументу, щоб дозволити нуль або більше екземплярів аргументу:

    'mail:send {user?*}'

<a name="option-arrays"></a>
#### Параметр із безліччю значень

При визначенні параметра, що очікує безліч значень, кожне значення переданого команді параметра повинно мати префікс з ім'ям параметра:

    'mail:send {--id=*}'

Таку команду можна викликати, передавши кілька аргументів `--id`:

```shell
php artisan mail:send --id=1 --id=2
```

<a name="input-descriptions"></a>
### Описи даних, що вводяться

Ви можете призначити описи вхідним аргументам і параметрам, відокремивши ім'я аргумента від опису за допомогою двокрапки. Якщо вам потрібно трохи більше місця для визначення вашої команди, то розподіліть визначення на кілька рядків:

    /**
     * Ім'я та сигнатура консольної команди.
     *
     * @var string
     */
    protected $signature = 'mail:send
                            {user : The ID of the user}
                            {--queue : Whether the job should be queued}';

<a name="prompting-for-missing-input"></a>
### Запит відсутнього введення

Якщо ваша команда містить обов'язкові аргументи, користувач отримає повідомлення про помилку, якщо вони не були надані. Як альтернативу, ви можете налаштувати вашу команду так, щоб автоматично запитувати користувача за відсутності необхідних аргументів, реалізувавши інтерфейс `PromptsForMissingInput`:

    <?php

    namespace App\Console\Commands;

    use Illuminate\Console\Command;
    use Illuminate\Contracts\Console\PromptsForMissingInput;

    class SendEmails extends Command implements PromptsForMissingInput
    {
        /**
         * Ім'я та сигнатура консольної команди.
         *
         * @var string
         */
        protected $signature = 'mail:send {user}';

        // ...
    }

Якщо Laravel повинен отримати обов'язковий аргумент від користувача, він автоматично запитає у користувача цей аргумент, формулюючи питання розумно з використанням імені або опису аргументу. Якщо ви хочете налаштувати питання, що використовується для отримання обов'язкового аргументу, реалізуйте метод `promptForMissingArgumentsUsing`, що повертає масив запитань з ключами, що відповідають іменам аргументів:

    /**
     * Підказка про відсутність вхідних аргументів за допомогою повернутих запитань.
     *
     * @return array<string, string>
     */
    protected function promptForMissingArgumentsUsing(): array
    {
        return [
            'user' => 'Which user ID should receive the mail?',
        ];
    }

Ви також можете вказати текст заповнювача, використовуючи кортеж, що містить запитання і заповнювач:

    return [
        'user' => ['Which user ID should receive the mail?', 'E.g. 123'],
    ];


Якщо ви хочете повністю контролювати запит, ви можете надати замикання, яке буде запитувати користувача і повертати його відповідь:

    use App\Models\User;
    use function Laravel\Prompts\search;

    // ...

    return [
        'user' => fn () => search(
            label: 'Search for a user:',
            placeholder: 'E.g. Taylor Otwell',
            options: fn ($value) => strlen($value) > 0
                ? User::where('name', 'like', "%{$value}%")->pluck('name', 'id')->all()
                : []
        ),
    ];

> [!NOTE]
> Детальна документація щодо [Laravel Prompts](/docs/{{version}}/prompts) містить додаткову інформацію про доступні запити та їхнє використання.


Якщо ви хочете запросити у користувача вибір або введення опцій, ви можете включити підказки в метод `handle` вашої команди. Однак, якщо ви хочете запитувати у користувача тільки тоді, коли йому було автоматично запропоновано ввести відсутні аргументи, ви можете реалізувати метод `afterPromptingForMissingArguments`:

    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;
    use function Laravel\Prompts\confirm;

    // ...

    /**
     * Виконати дії після запиту користувача щодо відсутніх аргументів
     */
    protected function afterPromptingForMissingArguments(InputInterface $input, OutputInterface $output): void
    {
        $input->setOption('queue', confirm(
            label: 'Would you like to queue the mail?',
            default: $this->option('queue')
        ));
    }

<a name="command-io"></a>
## Введення/виведення команди

<a name="retrieving-input"></a>
### Отримання вхідних даних

Під час виконання команди вам, імовірно, буде потрібно отримати доступ до значень аргументів і параметрів, прийнятих командою. Для цього ви можете використовувати методи `argument` і `option`. Якщо аргумент або параметр не існує, то буде повернуто значення `null`.

    /**
     * Виконати консольну команду.
     */
    public function handle(): void
    {
        $userId = $this->argument('user');

        //
    }

Якщо вам потрібно отримати всі аргументи у вигляді масиву, викличте метод `arguments`:

    $arguments = $this->arguments();

Параметри можуть бути отримані так само легко, як і аргументи, використовуючи метод `option`. Щоб отримати всі параметри у вигляді масиву, викличте метод `options`:

    // Отримання певного параметра ...
    $queueName = $this->option('queue');

    // Отримання всіх параметрів у вигляді масиву ...
    $options = $this->options();

<a name="prompting-for-input"></a>
### Запит для введення даних
> [!NOTE]
> [Laravel Prompts](/docs/{{version}}}/prompts) - це PHP-пакет для додавання гарних і зручних форм до вашого консольного додатка з функціями, аналогічними до браузеру, зокрема з текстом заповнювача та перевіркою даних.

Крім відображення виводу, ви можете попросити користувача надати дані під час виконання вашої команди. Метод `ask` відобразить користувачеві вказане запитання, прийме його введення, а потім поверне ці дані, отримані від користувача, назад у команду:

    /**
      * Виконати консольну команду.
     */
    public function handle(): void
    {
        $name = $this->ask('What is your name?');

        // ...
    }


Метод `ask` також приймає необов'язковий другий аргумент, який визначає значення за замовчуванням, що повертається, якщо користувач не надав введення:

    $name = $this->ask('What is your name?', 'Taylor');

Метод `secret` схожий на `ask`, але введення користувача не буде видно йому в консолі під час введення. Цей метод корисний під час запиту конфіденційної інформації, наприклад, пароля:

    $password = $this->secret('What is the password?');

<a name="asking-for-confirmation"></a>
#### Запит підтвердження

Якщо вам потрібно отримати від користувача просте підтвердження «yes or no», то ви можете використовувати метод `confirm`. За замовчуванням цей метод повертає значення `false`. Однак, якщо користувач вводить `y` або `yes` у відповідь на запит, то метод повертає `true`.

    if ($this->confirm('Do you wish to continue?')) {
        // ...
    }

За бажанням можна вказати, що запит підтвердження повинен за замовчуванням повертати `true`, передавши `true` як другий аргумент методу `confirm`:

    if ($this->confirm('Do you wish to continue?', true)) {
        // ...
    }

<a name="auto-completion"></a>
#### Автозавершення

Метод `anticipate` використовується для автоматичного завершення можливих варіантів. Користувач, як і раніше, може дати будь-яку відповідь, незалежно від підказок автозавершення:

    $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);

Як альтернативу, ви можете передати замикання як другий аргумент методу `anticipate`. Замикання буде викликатися кожного разу, коли користувач вводить символ. Замикання має приймати строковий параметр, що містить введені користувачем дані, і повертати масив варіантів для автозавершення:

    $name = $this->anticipate('What is your address?', function (string $input) {
        // Повернути варіанти для автоматичного завершення ...
    });

<a name="multiple-choice-questions"></a>
#### Запитання з множинним вибором

Якщо потрібно надати користувачеві визначений набір варіантів для вибору під час постановки запитання, то використовуйте метод `choice`. Ви можете встановити індекс масиву для значення, що повертається за замовчуванням, якщо не вибрано жодного з варіантів, передавши індекс як третій аргумент методу:

    $name = $this->choice(
        'What is your name?',
        ['Taylor', 'Dayle'],
        $defaultIndex
    );

Крім того, метод `choice` приймає необов'язкові четвертий і п'ятий аргументи для визначення максимальної кількості спроб вибору дійсної відповіді і того, чи дозволено множинний вибір:

    $name = $this->choice(
        'What is your name?',
        ['Taylor', 'Dayle'],
        $defaultIndex,
        $maxAttempts = null,
        $allowMultipleSelections = false
    );

<a name="writing-output"></a>
### Виведення даних

Щоб вивести в консоль, використовуйте методи `line`, `info`, `comment`, `question`, `warn` і `error`. Кожен із цих методів використовуватиме відповідні ANSI-кольори. Наприклад, давайте покажемо користувачеві деяку загальну інформацію. Зазвичай метод `info` відображається в консолі у вигляді зеленого тексту:

    /**
     * Виконати консольну команду.
     */
    public function handle(): void
    {
        // ...

        $this->info('The command was successful!');
    }

Для відображення повідомлення про помилку використовуйте метод `error`. Текст повідомлення про помилку зазвичай відображається червоним кольором:

    $this->error('Something went wrong!');

Ви можете використовувати метод `line` для відображення простого незабарвленого тексту:

    $this->line('Display this on the screen');

Ви можете використовувати метод `newLine` для відображення порожнього рядка:

    // Вивести один порожній рядок ...
    $this->newLine();

    // Вивести три порожні рядки ...
    $this->newLine(3);

<a name="tables"></a>
#### Таблиці

Метод `table` спрощує коректне форматування декількох рядків / стовпців даних. Все, що вам потрібно зробити, це вказати імена стовпців і дані для таблиці, і Laravel автоматично розрахує відповідну ширину і висоту таблиці:
<!--  -->

    use App\Models\User;

    $this->table(
        ['Name', 'Email'],
        User::all(['name', 'email'])->toArray()
    );

<a name="progress-bars"></a>
#### Індикатори виконання

Для довгостроково виконуваних завдань було б корисно показати індикатор виконання, що інформує користувача про те, наскільки завершено завдання. Використовуючи метод `withProgressBar`, Laravel буде відображати індикатор виконання і просувати його для кожної ітерації на задане повторюване значення:

    use App\Models\User;

    $users = $this->withProgressBar(User::all(), function (User $user) {
        $this->performTask($user);
    });

Іноді може знадобитися більший контроль над просуванням індикатора виконання. Спочатку визначте загальну кількість кроків, через які проходитиме процес. Потім просувайте індикатор виконання після обробки кожного елемента:

    $users = App\Models\User::all();

    $bar = $this->output->createProgressBar(count($users));

    $bar->start();

    foreach ($users as $user) {
        $this->performTask($user);

        $bar->advance();
    }

    $bar->finish();

> [!NOTE]
> Для отримання додаткової інформації ознайомтеся з [розділом документації компонента Symfony Progress Bar](https://symfony.com/doc/7.0/components/console/helpers/progressbar.html).

<a name="registering-commands"></a>
## Реєстрація команд

За замовчуванням Laravel автоматично реєструє всі команди в каталозі `app/Console/Commands`. Однак ви можете доручити Laravel сканувати інші каталоги на наявність команд Artisan, використовуючи метод `withCommands` у файлі `bootstrap/app.php` вашого додатка:

    ->withCommands([
        __DIR__.'/../app/Domain/Orders/Commands',
    ])

За необхідності ви також можете зареєструвати команди вручну, вказавши ім'я класу команди в методі `withCommands`:

    use App\Domain\Orders\Commands\SendEmails;

    ->withCommands([
        SendEmails::class,
    ])

Коли Artisan завантажиться, усі команди у вашому застосунку будуть оброблені [сервісним контейнером](/docs/{{version}}}/container) і зареєстровані в Artisan.

<a name="programmatically-executing-commands"></a>
## Програмне виконання команд

За бажанням можна виконати команду Artisan за межами CLI. Наприклад, ви можете запустити команду Artisan у маршруті або контролері. Для цього можна використовувати метод `call` фасаду `Artisan`. Метод `call` приймає як перший аргумент або ім'я сигнатури команди, або ім'я класу, а як другий - масив параметрів команди. Буде повернуто код виходу / повернення:

    use Illuminate\Support\Facades\Artisan;

    Route::post('/user/{user}/mail', function (string $user) {
        $exitCode = Artisan::call('mail:send', [
            'user' => $user, '--queue' => 'default'
        ]);

        //...
    });

Крім того, ви можете передати методу `call` команду повністю у вигляді рядка:

    Artisan::call('mail:send 1 --queue=default');

<a name="passing-array-values"></a>
#### Передача масиву значень

Якщо ваша команда визначає параметр, який приймає масив, то ви можете передати масив значень цьому параметру:

    use Illuminate\Support\Facades\Artisan;

    Route::post('/mail', function () {
        $exitCode = Artisan::call('mail:send', [
            '--id' => [5, 13]
        ]);
    });

<a name="passing-boolean-values"></a>
#### Передача значень логічного типу

Якщо необхідно вказати значення параметра, який не приймає рядкових значень, наприклад прапор `--force` у команді `migrate:refresh`, то ви повинні передати `true` або `false` як значення параметра:

    $exitCode = Artisan::call('migrate:refresh', [
        '--force' => true,
    ]);

<a name="queueing-artisan-commands"></a>
#### Черги команд Artisan

Використовуючи метод `queue` фасаду `Artisan`, ви можете навіть поставити команди Artisan у чергу, щоб вони оброблялися у фоновому режимі [обробником черги](/docs/{{version}}}/queues). Перед використанням цього методу переконайтеся, що ви налаштували черги і був запущений слухач черги:

    use Illuminate\Support\Facades\Artisan;

    Route::post('/user/{user}/mail', function (string $user) {
        Artisan::queue('mail:send', [
            'user' => $user, '--queue' => 'default'
        ]);

        //...
    });

Використовуючи методи `onConnection` і `onQueue`, ви також можете вказати з'єднання або чергу, в яку має бути надіслано команду Artisan:

    Artisan::queue('mail:send', [
        'user' => 1, '--queue' => 'default'
    ])->onConnection('redis')->onQueue('commands');

<a name="calling-commands-from-other-commands"></a>
### Виклик команд з інших команд

За бажанням можна викликати інші команди з наявної команди Artisan. Ви можете зробити це за допомогою методу `call`. Метод `call` приймає ім'я команди та масив аргументів / параметрів команди:

    /**
     * Виконати консольну команду.
     */
    public function handle(): void
    {
        $this->call('mail:send', [
            'user' => 1, '--queue' => 'default'
        ]);

        //...
    }

Якщо ви хочете викликати іншу консольну команду в тихому режимі, то використовуйте метод `callSilently`. Метод `callSilently` має ту саму сигнатуру, що й метод `call`:

    $this->callSilently('mail:send', [
        'user' => 1, '--queue' => 'default'
    ]);

<a name="signal-handling"></a>
## Обробка сигналів

Як ви, можливо, знаєте, операційні системи дозволяють надсилати сигнали запущеним процесам. Наприклад, сигнал `SIGTERM` використовується операційними системами для запиту програмі про завершення виконання. Якщо ви хочете прослуховувати сигнали у ваших консольних командах Artisan і виконувати код, коли вони виникають, ви можете використовувати метод `trap`:

    /**
     * Виконати консольну команду.
     */
    public function handle(): void
    {
        $this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);

        while ($this->shouldKeepRunning) {
            // ...
        }
    }


Для прослуховування декількох сигналів одразу, ви можете надати масив сигналів методу `trap`:

    $this->trap([SIGTERM, SIGQUIT], function (int $signal) {
        $this->shouldKeepRunning = false;

        dump($signal); // SIGTERM / SIGQUIT
    });

<a name="stub-customization"></a>
## Налаштування заготовок команд (stubs)

Команди `make` консолі Artisan використовуються для створення різних класів, таких як контролери, завдання, міграції та тести. Ці класи створюються за допомогою файлів «заготовок», які заповнюються значеннями на основі ваших вхідних даних. Однак, іноді може знадобитися внести невеликі зміни в файли, що створюються за допомогою Artisan. Для цього можна використовувати команду `stub:publish`, щоб опублікувати найпоширеніші заготовки для їх подальшої зміни:

```shell
php artisan stub:publish
```

Опубліковані заготовки будуть розташовані в каталозі `stubs` кореня вашої програми. Будь-які зміни, внесені вами в ці заготовки, будуть враховані при створенні відповідних класів за допомогою команд `make` Artisan.

<a name="events"></a>
## Події

Artisan запускає три події під час виконання команд: `Illuminate\Console\Events\ArtisanStarting`, `Illuminate\Console\Events\CommandStarting`, і `Illuminate\Console\Events\CommandFinished`. Подія `ArtisanStarting` виконується відразу після запуску Artisan. Потім подія `CommandStarting` виконується безпосередньо перед запуском команди. Нарешті, подія `CommandFinished` виконується після завершення команди.
