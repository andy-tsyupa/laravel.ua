# HTTP Сесії

- [Вступ](#introduction)
    - [Конфігурація](#configuration)
    - [Необхідні умови для водія](#driver-prerequisites)
- [Взаємодія з сесією](#interacting-with-the-session)
    - [Отримання даних](#retrieving-data)
    - [Зберігання даних](#storing-data)
    - [Дані флеш-пам'яті](#flash-data)
    - [Видалення даних](#deleting-data)
    - [Відновлення ідентифікатора сеансу](#regenerating-the-session-id)
- [Блокування сесії](#session-blocking)
- [Додавання користувацьких драйверів сеансів](#adding-custom-session-drivers)
    - [Впровадження драйвера](#implementing-the-driver)
    - [Реєстрація водія](#registering-the-driver)

<a name="introduction"></a>
## Вступ

Оскільки HTTP-додатки не мають статусу, сеанси надають можливість зберігати інформацію про користувача під час декількох запитів. Ця інформація про користувача зазвичай розміщується в постійному сховищі / бекенді, до якого можна отримати доступ з наступних запитів.

Laravel постачається з різноманітними сесійними бекендами, доступ до яких здійснюється через виразний, уніфікований API. Включена підтримка популярних бекендів, таких як [Memcached](https://memcached.org), [Redis](https://redis.io) та баз даних.

<a name="configuration"></a>
### Конфігурація

Файл конфігурації сеансу вашого додатку зберігається за адресою `config/session.php`. Обов'язково ознайомтеся з опціями, доступними в цьому файлі. За замовчуванням Laravel налаштовано на використання драйвера сеансу `database`.

Параметр конфігурації сеансу `driver` визначає, де будуть зберігатися дані сеансу для кожного запиту. Laravel включає різноманітні драйвери:

<div class="content-list" markdown="1">

- `file` - сесії зберігаються в `storage/framework/sessions`.
- `cookie` - сесії зберігаються в безпечних, зашифрованих файлах cookie.
- `database` - сесії зберігаються в реляційній базі даних.
- `memcached` / `redis` - сесії зберігаються в одному з цих швидких сховищ, заснованих на кеші.
- `dynamodb` - сесії зберігаються в AWS DynamoDB.
- `array` - сесії зберігаються в масиві PHP і не зберігаються.

</div>

> [!NOTE]  
> Драйвер масиву використовується переважно під час [тестування](/docs/{{version}}/testing) і запобігає збереженню даних, збережених у сеансі.

<a name="driver-prerequisites"></a>
### Необхідні умови для водія

<a name="database"></a>
#### База даних

При використанні драйвера сеансу `database` вам потрібно переконатися, що у вас є таблиця бази даних, яка містить дані сеансу. Зазвичай, це включено до стандартного файлу Laravel `0001_01_01_000000_create_users_table.php` [міграція бази даних](/docs/{{version}}/migrations); однак, якщо з якихось причин у вас немає таблиці `сесій`, ви можете скористатися командою `make:session-table` Artisan для створення цієї міграції:

```shell
php artisan make:session-table

php artisan migrate
```

<a name="redis"></a>
#### Redis

Перш ніж використовувати сеанси Redis з Laravel, вам потрібно встановити розширення PHP PhpRedis через PECL або встановити пакунок `predis/predis` (~1.0) через Composer. Для отримання додаткової інформації про налаштування Redis зверніться до [документації по Redis](/docs/{{version}}/redis#configuration).

> [!NOTE]  
> Змінна оточення `SESSION_CONNECTION` або опція `connection` у файлі конфігурації ` session.php` може бути використана для визначення з'єднання Redis, яке використовується для зберігання сесій.

<a name="interacting-with-the-session"></a>
## Взаємодія з сесією

<a name="retrieving-data"></a>
### Отримання даних

У Laravel є два основних способи роботи з даними сеансу: глобальний хелпер `сеанс` та екземпляр `запит`. Спочатку розглянемо доступ до сесії через екземпляр `Request`, який може бути підказаний на закритті маршруту або методі контролера. Пам'ятайте, що залежності методів контролерів автоматично підключаються через контейнер Laravel [сервісний контейнер](/docs/{{version}}/container):

    <?php

    namespace App\Http\Controllers;

    use Illuminate\Http\Request;
    use Illuminate\View\View;

    class UserController extends Controller
    {
        /**
         * Show the profile for the given user.
         */
        public function show(Request $request, string $id): View
        {
            $value = $request->session()->get('key');

            // ...

            $user = $this->users->find($id);

            return view('user.profile', ['user' => $user]);
        }
    }

Коли ви отримуєте елемент із сеансу, ви також можете передати значення за замовчуванням як другий аргумент методу `get`. Це значення за замовчуванням буде повернуто, якщо вказаний ключ не існує у сеансі. Якщо ви передаєте закриття як значення за замовчуванням до методу `get` і запитуваний ключ не існує, буде виконано закриття і повернуто його результат:

    $value = $request->session()->get('key', 'default');

    $value = $request->session()->get('key', function () {
        return 'default';
    });

<a name="the-global-session-helper"></a>
#### Глобальний помічник сесії

Ви також можете використовувати глобальну PHP-функцію `session` для отримання та зберігання даних у сеансі. Якщо викликати допоміжну функцію `session` з одним рядковим аргументом, вона поверне значення ключа сеансу. Якщо ж помічник викликається з масивом пар ключ/значення, то ці значення будуть збережені в сеансі:

    Route::get('/home', function () {
        // Отримати фрагмент даних з сесії...
        $value = session('key');

        // Вказівка значення за замовчуванням...
        $value = session('key', 'default');

        // Зберігати фрагмент даних у сесії...
        session(['key' => 'value']);
    });

> [!NOTE]  
> Практична різниця між використанням сеансу через екземпляр HTTP-запиту та використанням глобального хелпера `сеансу` є незначною. Обидва методи можна [протестувати](/docs/{{version}}/testing) за допомогою методу `assertSessionHas`, який доступний у всіх ваших тестових прикладах.

<a name="retrieving-all-session-data"></a>
#### Отримання всіх даних сеансу

Якщо ви хочете отримати всі дані за сеанс, ви можете скористатися методом `all`:

    $data = $request->session()->all();

<a name="retrieving-a-portion-of-the-session-data"></a>
#### Отримання частини даних сеансу

Методи `only` та `except` можна використовувати для отримання підмножини даних сеансу:

    $data = $request->session()->only(['username', 'email']);

    $data = $request->session()->except(['username', 'email']);

<a name="determining-if-an-item-exists-in-the-session"></a>
#### Визначення наявності елемента в сеансі

Щоб визначити, чи присутній елемент у сеансі, ви можете використати метод `has`. Метод `has` повертає значення `true`, якщо елемент присутній і не є `null`:

    if ($request->session()->has('users')) {
        // ...
    }

Щоб визначити, чи присутній елемент у сеансі, навіть якщо його значення `null`, ви можете використати метод `exists`:

    if ($request->session()->exists('users')) {
        // ...
    }

Щоб визначити, чи відсутній елемент у сеансі, ви можете використати метод `missing`. Метод `missing` повертає значення `true`, якщо елемент відсутній:

    if ($request->session()->missing('users')) {
        // ...
    }

<a name="storing-data"></a>
### Зберігання даних

Для зберігання даних у сесії зазвичай використовується метод `put екземпляра запиту або глобальний хелпер `сесія`:

    // Через екземпляр запиту...
    $request->session()->put('key', 'value');

    // За допомогою глобального помічника «сеанс»...
    session(['key' => 'value']);

<a name="pushing-to-array-session-values"></a>
#### Перехід до значень сеансу масиву

Метод `push` можна використовувати для додавання нового значення до значення сеансу, яке є масивом. Наприклад, якщо ключ `user.teams` містить масив назв команд, ви можете додати нове значення до цього масиву таким чином:

    $request->session()->push('user.teams', 'developers');

<a name="retrieving-deleting-an-item"></a>
#### Пошук і видалення елемента

Метод `pull` витягне і видалить елемент із сеансу за один оператор:

    $value = $request->session()->pull('key', 'default');

<a name="#incrementing-and-decrementing-session-values"></a>
#### Збільшення та зменшення вартості сесії

Якщо дані вашої сесії містять ціле число, яке ви хочете збільшити або зменшити, ви можете використовувати методи `increment` і `crecrement`:

    $request->session()->increment('count');

    $request->session()->increment('count', $incrementBy = 2);

    $request->session()->decrement('count');

    $request->session()->decrement('count', $decrementBy = 2);

<a name="flash-data"></a>
### Дані флеш-пам'яті

Іноді вам може знадобитися зберегти елементи в сеансі для наступного запиту. Ви можете зробити це за допомогою методу `flash`. Дані, збережені в сесії за допомогою цього методу, будуть доступні негайно і під час наступного HTTP-запиту. Після наступного HTTP-запиту флеш-дані будуть видалені. Флеш-дані в першу чергу корисні для короткочасних повідомлень про стан:

    $request->session()->flash('status', 'Task was successful!');

Якщо вам потрібно зберегти флеш-дані для декількох запитів, ви можете використати метод `reflash`, який збереже всі флеш-дані для додаткового запиту. Якщо вам потрібно зберегти лише певні дані, ви можете використати метод `keep`:

    $request->session()->reflash();

    $request->session()->keep(['username', 'email']);

Щоб зберегти дані флеш-пам'яті лише для поточного запиту, ви можете використати метод `now`:

    $request->session()->now('status', 'Task was successful!');

<a name="deleting-data"></a>
### Видалення даних

Метод `forget` видалить частину даних із сеансу. Якщо ви хочете видалити всі дані з сесії, ви можете скористатися методом `flush`:

    // Забудьте один ключ...
    $request->session()->forget('name');

    // Забудьте про кілька клавіш...
    $request->session()->forget(['name', 'status']);

    $request->session()->flush();

<a name="regenerating-the-session-id"></a>
### Відновлення ідентифікатора сеансу

Регенерація ідентифікатора сеансу часто робиться для того, щоб запобігти використанню зловмисниками атаки [фіксації сеансу](https://owasp.org/www-community/attacks/Session_fixation) на вашу програму.

Laravel автоматично відновлює ідентифікатор сеансу під час автентифікації, якщо ви використовуєте один з наборів Laravel [стартові набори для додатків](/docs/{{version}}/starter-kits) або [Laravel Fortify](/docs/{{version}}/fortify); однак, якщо вам потрібно відновити ідентифікатор сеансу вручну, ви можете використати метод `regenerate`:

    $request->session()->regenerate();

Якщо вам потрібно відновити ідентифікатор сеансу і видалити всі дані з сеансу за один оператор, ви можете скористатися методом `invalidate`:

    $request->session()->invalidate();

<a name="session-blocking"></a>
## Блокування сесії

> [!WARNING]  
> Щоб використовувати блокування сеансів, ваша програма повинна використовувати драйвер кешу, який підтримує [атомарні блокування](/docs/{{version}}/cache#atomic-locks). Наразі такими драйверами кешу є драйвери `memcached`, `dynamodb`, `redis`, `database`, `file` та `array`. Крім того, ви не можете використовувати драйвер сеансу `cookie`.

За замовчуванням Laravel дозволяє запитам, що використовують одну і ту ж сесію, виконуватися одночасно. Так, наприклад, якщо ви використовуєте HTTP-бібліотеку JavaScript для створення двох HTTP-запитів до вашого додатку, вони будуть виконані одночасно. Для багатьох додатків це не є проблемою; однак, втрата даних сеансу може статися в невеликій підмножині додатків, які роблять одночасні запити до двох різних кінцевих точок додатків, які обидва записують дані в сеанс.

Щоб запобігти цьому, Laravel надає функціональність, яка дозволяє обмежити одночасні запити для даного сеансу. Для початку ви можете просто додати метод `block` до визначення маршруту. У цьому прикладі вхідний запит до кінцевої точки `/profile` отримає блокування сеансу. Поки це блокування утримується, будь-які вхідні запити до кінцевих точок `/profile` або `/order`, які мають той самий ідентифікатор сеансу, чекатимуть на завершення виконання першого запиту, перш ніж продовжити виконання своїх запитів:

    Route::post('/profile', function () {
        // ...
    })->block($lockSeconds = 10, $waitSeconds = 10)

    Route::post('/order', function () {
        // ...
    })->block($lockSeconds = 10, $waitSeconds = 10)

Метод `block` приймає два необов'язкові аргументи. Перший аргумент, який приймає метод `block` - це максимальна кількість секунд, на яку має утримуватися блокування сеансу, перш ніж його буде знято. Звичайно, якщо запит завершить виконання раніше цього часу, то блокування буде знято раніше.

Другий аргумент, що приймається методом `block` - це кількість секунд, протягом яких запит повинен чекати на блокування сеансу. Виключення `Illuminate\Contracts\Cache\LockTimeoutException` буде згенеровано, якщо запит не зможе отримати блокування сеансу протягом заданої кількості секунд.

Якщо жоден з цих аргументів не передано, блокування буде отримано максимум на 10 секунд, і запити будуть чекати максимум 10 секунд, намагаючись отримати блокування:

    Route::post('/profile', function () {
        // ...
    })->block()

<a name="adding-custom-session-drivers"></a>
## Додавання користувацьких драйверів сеансів

<a name="implementing-the-driver"></a>
### Впровадження драйвера

Якщо жоден з існуючих драйверів сеансів не відповідає потребам вашої програми, Laravel дозволяє написати власний обробник сеансів. Ваш власний драйвер сеансу має реалізовувати вбудований інтерфейс `SessionHandlerInterface` у PHP. Цей інтерфейс містить лише кілька простих методів. Реалізація заглушки MongoDB виглядає наступним чином:

    <?php

    namespace App\Extensions;

    class MongoSessionHandler implements \SessionHandlerInterface
    {
        public function open($savePath, $sessionName) {}
        public function close() {}
        public function read($sessionId) {}
        public function write($sessionId, $data) {}
        public function destroy($sessionId) {}
        public function gc($lifetime) {}
    }

> [!NOTE]  
> Laravel не постачається з каталогом для розміщення ваших розширень. Ви можете розмістити їх де завгодно. У цьому прикладі ми створили каталог `Extensions` для розміщення `MongoSessionHandler`.

Оскільки призначення цих методів не завжди зрозуміле, давайте швидко розглянемо, що робить кожен з них:

<div class="content-list" markdown="1">

- Метод `open` зазвичай використовується у файлових системах зберігання сеансів. Оскільки Laravel постачається з `файловим` драйвером сеансів, вам рідко потрібно буде щось передавати у цей метод. Ви можете просто залишити цей метод порожнім.
- Метод `close`, як і метод `open`, також зазвичай можна ігнорувати. Для більшості драйверів він не потрібен.
- Метод `read` повинен повертати рядкову версію даних сеансу, пов'язану з заданим `$sessionId`. Немає необхідності виконувати серіалізацію або інше кодування при отриманні або зберіганні даних сеансу у вашому драйвері, оскільки Laravel виконає серіалізацію за вас.
- Метод `write` повинен записати заданий рядок `$data`, асоційований з `$sessionId`, до деякої постійної системи зберігання, такої як MongoDB або іншої системи зберігання на ваш вибір.  Знову ж таки, ви не повинні виконувати ніякої серіалізації - Laravel вже впорається з цим за вас.
- Метод `destroy` повинен видалити дані, пов'язані з `$sessionId`, з постійного сховища.
- Метод `gc` має знищити усі дані сеансу, які є старшими за заданий `$lifetime`, який є міткою часу у UNIX. Для систем, що самознищуються, таких як Memcached та Redis, цей метод можна залишити порожнім.

</div>

<a name="registering-the-driver"></a>
### Реєстрація водія

Після того, як ваш драйвер реалізовано, ви можете зареєструвати його у Laravel. Щоб додати додаткові драйвери до сеансового бекенду Laravel, ви можете скористатися методом `extend`, який надається у [фасади](/docs/{{version}}/facades). Вам слід викликати метод `extend` з методу `boot` [постачальника послуг](/docs/{{version}}/providers). Ви можете зробити це з існуючого `App\Providers\AppServiceProvider` або створити абсолютно нового провайдера:

    <?php

    namespace App\Providers;

    use App\Extensions\MongoSessionHandler;
    use Illuminate\Contracts\Foundation\Application;
    use Illuminate\Support\Facades\Session;
    use Illuminate\Support\ServiceProvider;

    class SessionServiceProvider extends ServiceProvider
    {
        /**
         * Реєструйте будь-які сервіси додатків.
         */
        public function register(): void
        {
            // ...
        }

        /**
         * Завантажуйте будь-які сервіси додатків.
         */
        public function boot(): void
        {
            Session::extend('mongo', function (Application $app) {
                // Повернути реалізацію інтерфейсу SessionHandlerInterface...
                return new MongoSessionHandler;
            });
        }
    }

Після реєстрації драйвера сеансу ви можете вказати драйвер `mongo` як драйвер сеансу вашої програми за допомогою змінної оточення `SESSION_DRIVER` або у файлі конфігурації програми `config/session.php`.
