# Кешування

- [Вступ](#introduction)
- [Конфігурування](#configuration)
    - [Попередня підготовка драйверів](#driver-prerequisites)
- [Керування кешем програми](#cache-usage)
    - [Отримання екземпляра кеша](#obtaining-a-cache-instance)
    - [Отримання елементів із кешу](#retrieving-items-from-the-cache)
    - [Збереження елементів у кеші](#storing-items-in-the-cache)
    - [Видалення елементів із кешу](#removing-items-from-the-cache)
    - [Глобальний помічник кешу](#the-cache-helper)
- [Атомарні блокування](#atomic-locks)
    - [Керування блокуваннями](#managing-locks)
    - [Керування блокуваннями між процесами](#managing-locks-across-processes)
- [Додавання власних драйверів кешу](#adding-custom-cache-drivers)
    - [Написання драйвера кешу](#writing-the-driver)
    - [Реєстрація драйвера кешу](#registering-the-driver)
- [Події](#events)

<a name="introduction"></a>
## Вступ

Деякі завдання з вилучення або обробки даних, що виконуються вашим додатком, можуть вимагати великих ресурсів ЦП або зайняти кілька секунд. У цьому випадку витягнуті дані зазвичай кешують на деякий час, щоб їх можна було швидко витягти під час наступних запитів тих самих даних. Кешовані дані зазвичай зберігаються у сховищі зі швидким доступом даних, наприклад, [Memcached](https://memcached.org) або [Redis](https://redis.io).

На щастя, Laravel пропонує виразний уніфікований API для різних серверів кешування, що дає змогу вам скористатися їхнім неймовірно швидким витяганням даних і прискорити роботу вашого веб-додатка.

<a name="configuration"></a>
## Конфігурування

Файл конфігурації кеша вашого додатка міститься в `config/cache.php`. У цьому файлі ви можете вказати, яке сховище кешу ви хочете використовувати за замовчуванням для всього додатку. Laravel з коробки підтримує популярні механізми кешування, як-от [Memcached](https://memcached.org), [Redis](https://redis.io), [DynamoDB](https://aws.amazon.com/dynamodb) і реляційні бази даних. Крім того, доступний драйвер кешування на основі файлів, тоді як драйвери `array` і `null` надають зручні механізми кешування для ваших автоматичних тестів.

Файл конфігурації кешу також містить безліч інших параметрів, які ви можете переглянути. За замовчуванням Laravel налаштований на використання драйвера кешу `database`, який зберігає серіалізовані кешовані об'єкти в базі даних вашої програми.

<a name="driver-prerequisites"></a>
### Попередня підготовка драйверів

<a name="prerequisites-database"></a>
#### Попередня підготовка драйвера на основі бази даних

У разі використання драйвера кешу `database` вам знадобиться таблиця бази даних, що містить дані кешу. Зазвичай це включено до стандартного файлу Laravel `0001_01_01_01_000001_create_cache_table.php` [міграції бази даних](/docs/{{version}}}/migrations); однак, якщо ваш додаток не містить цієї міграції, ви можете використовувати Artisan-команду `make:cache-table` для її створення:

```shell
php artisan make:cache-table

php artisan migrate
```

<a name="memcached"></a>
#### Попередня підготовка драйвера на основі Memcached

Для використання драйвера Memcached потрібно встановити [пакет Memcached PECL](https://pecl.php.net/package/memcached). Ви можете перерахувати всі ваші сервери Memcached у файлі конфігурації `config/cache.php`. Цей файл уже містить запис `memcached.servers` для початку:

    'memcached' => [
        // ...

        'servers' => [
            [
                'host' => env('MEMCACHED_HOST', '127.0.0.1'),
                'port' => env('MEMCACHED_PORT', 11211),
                'weight' => 100,
            ],
        ],
    ],

За необхідності ви можете задати параметр `host` сокета UNIX. Якщо ви це зробите, то параметр `port` має бути заданий як `0`:

    'memcached' => [
        [
        // ...

        'servers' => [
            [
                'host' => '/var/run/memcached/memcached.sock',
                'port' => 0,
                'weight' => 100
            ],
        ],
    ],

<a name="redis"></a>
#### Попередня підготовка драйвера на основі Redis

Перед використанням драйвера кеша Redis, вам потрібно буде або встановити розширення PHP PhpRedis через PECL, або встановити пакет `predis/predis` (~ 2.0) через Composer. [Laravel Sail](/docs/{{version}}}/sail) вже включає це розширення. Крім того, на офіційних платформах розгортання Laravel, таких як [Laravel Forge](https://forge.laravel.com) і [Laravel Vapor](https://vapor.laravel.com), розширення PhpRedis встановлено за замовчуванням.

Для отримання додаткової інформації про налаштування Redis зверніться до його [сторінки документації Laravel](/docs/{{version}}/redis#configuration).

<a name="dynamodb"></a>
#### Попередня підготовка драйвера на основі DynamoDB

Перед використанням драйвера кешу [DynamoDB](https://aws.amazon.com/dynamodb) необхідно створити таблицю DynamoDB для зберігання всіх кешованих даних. Зазвичай це `cache`. Назва таблиці має збігатися з `stores.dynamodb.table` у конфігураційному файлі `cache`. Ім'я таблиці також можна задати за допомогою змінної середовища `DYNAMODB_CACHE_TABLE`.

Ця таблиця також повинна мати строковий ключ розділу з ім'ям, що відповідає значенню елемента конфігурації `stores.dynamodb.attributes.key` у конфігураційному файлі `cache`. За замовчуванням це `key`.

Зазвичай DynamoDB не видаляє елементи з вичерпаним терміном дії з таблиці заздалегідь. Тому вам слід [увімкнути Time to Live (TTL)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html) на таблиці. Під час налаштування параметрів TTL таблиці вам слід встановити ім'я атрибута TTL на `expires_at`.

Потім встановіть AWS SDK, щоб ваш додаток Laravel міг взаємодіяти з DynamoDB:

```shell
composer require aws/aws-sdk-php
```

Крім того, вам слід переконатися, що вказані значення для параметрів конфігурації сховища кешу DynamoDB. Зазвичай ці параметри, такі як `AWS_ACCESS_KEY_ID` і `AWS_SECRET_ACCESS_KEY`, повинні бути визначені у файлі конфігурації `.env` вашого додатка:

```php
'dynamodb' => [
    'driver' => 'dynamodb',
    'key' => env('AWS_ACCESS_KEY_ID'),
    'secret' => env('AWS_SECRET_ACCESS_KEY'),
    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
    'table' => env('DYNAMODB_CACHE_TABLE', 'cache'),
    'endpoint' => env('DYNAMODB_ENDPOINT'),
],
```

<a name="mongodb"></a>
#### MongoDB

Якщо ви використовуєте MongoDB, драйвер кешу `mongodb` надається офіційним пакетом `mongodb/laravel-mongodb` і може бути налаштований за допомогою підключення до бази даних `mongodb`. MongoDB підтримує індекси TTL, які можна використовувати для автоматичного очищення елементів кешу з вичерпаним терміном дії.

Для отримання додаткової інформації про налаштування MongoDB зверніться до [документації по кешу і блокуванням MongoDB](https://www.mongodb.com/docs/drivers/php/laravel-mongodb/current/cache/).

<a name="cache-usage"></a>
## Керування кешем програми

<a name="obtaining-a-cache-instance"></a>
### Отримання екземпляра кеша

Щоб отримати екземпляр сховища кеша, ви можете використовувати фасад `Cache`, який ми будемо використовувати в цій документації. Фасад `Cache` забезпечує зручний і короткий доступ до базових реалізацій контрактів кешування Laravel:

    <?php

    namespace App\Http\Controllers;

    use Illuminate\Support\Facades\Cache;

    class UserController extends Controller
    {
        /**
         * Показати список усіх користувачів програми.
         */
        public function index(): array
        {
            $value = Cache::get('key');

            return [
                // ...
            ];
        }
    }

<a name="accessing-multiple-cache-stores"></a>
#### Доступ до різних кеш-сховищ

Використовуючи фасад `Cache`, ви можете отримати доступ до різних сховищ кеша за допомогою методу `store`. Ключ, переданий методу `store`, має відповідати одному зі сховищ, перелічених у масиві `stores` вашого конфігураційного файлу `config/cache.php`:

    $value = Cache::store('file')->get('foo');

    Cache::store('redis')->put('bar', 'baz', 600); // 10 Minutes

<a name="retrieving-items-from-the-cache"></a>
### Отримання елементів із кешу

Метод `get` фасаду `Cache` використовується для вилучення елементів з кешу. Якщо елемент не існує в кеші, буде повернуто значення `null`. Якщо хочете, то ви можете передати другий аргумент методу `get`, вказавши значення за замовчуванням, яке ви хочете повернути, якщо елемент відсутній:

    $value = Cache::get('key');

    $value = Cache::get('key', 'default');

Ви навіть можете передати замикання як значення за замовчуванням. Результат замикання буде повернуто, якщо вказаний елемент не існує в кеші. Передача замикання дає змогу відкласти отримання значень за замовчуванням із бази даних або іншої зовнішньої служби:

    $value = Cache::get('key', function () {
        return DB::table(/* ... */)->get();
    });

<a name="determining-for-item-existence"></a>
#### Перевірка наявності елемента

Метод `has` використовується для визначення того, чи існує елемент у кеші. Цей метод також поверне `false`, якщо елемент існує, але його значення дорівнює `null`:

    if (Cache::has('key')) {
        // ...
    }

<a name="incrementing-decrementing-values"></a>
#### Збільшення та зменшення окремих значень у кеші

Методи `increment` і `decrement` можуть використовуватися для зміни значень цілочисельних елементів у кеші. Обидва методи приймають необов'язковий другий аргумент, що вказує величину збільшення або зменшення значення елемента:

    // Initialize the value if it does not exist...
    Cache::add('key', 0, now()->addHours(4));

    // Increment or decrement the value...
    Cache::increment('key');
    Cache::increment('key', $amount);
    Cache::decrement('key');
    Cache::decrement('key', $amount);

<a name="retrieve-store"></a>
#### Виконання замикання з подальшим збереженням і отриманням результату

Також ви можете не тільки отримати елемент із кешу, а й зберегти значення за замовчуванням, якщо запитаний елемент не існує. Наприклад, ви можете отримати всіх користувачів з кешу або, якщо вони не існують, отримати їх з бази даних і додати їх у кеш. Ви можете зробити це за допомогою методу `Cache::remember`:

    $value = Cache::remember('users', $seconds, function () {
        return DB::table('users')->get();
    });

Якщо елемент не існує в кеші, то замикання, передане методу `remember`, буде виконано, і його результат буде поміщено в кеш.

Ви можете використовувати метод `rememberForever`, щоб отримати елемент з кеша або зберегти його назавжди, якщо він не існує:

    $value = Cache::rememberForever('users', function () {
        return DB::table('users')->get();
    });

<a name="swr"></a>
#### Застаріло при повторній перевірці

При використанні методу `Cache::remember` у деяких користувачів може спостерігатися повільний час відгуку, якщо термін дії кешованого значення минув. Для певних типів даних може бути корисно дозволити обслуговування частково застарілих даних під час перерахунку кешованого значення у фоновому режимі, щоб у деяких користувачів не виникало повільної відповіді під час розрахунку кешованих значень. Це часто називають шаблоном «застарілого при повторній перевірці» («stale-while-revalidate»), і метод `Cache::flexible` забезпечує реалізацію цього шаблону.

Гнучкий метод приймає масив, який визначає, як довго кешоване значення вважається «свіжим», а коли воно стає «застарілим». Перше значення в масиві представляє кількість секунд, протягом яких кеш вважається свіжим, а друге значення визначає, як довго він може використовуватися як застарілі дані, перш ніж буде потрібен перерахунок.

Якщо запит зроблено у свіжому періоді (до першого значення), кеш повертається відразу без перерахунку. Якщо запит зроблено протягом періоду старіння (між двома значеннями), застаріле значення передається користувачеві, і [відкладена функція](/docs/{{version}}/helpers#deferred-functions) реєструється в оновити кешоване значення після надсилання відповіді користувачеві. Якщо запит зроблено після другого значення, кеш вважається простроченим, і значення негайно перераховується, що може призвести до повільнішої відповіді користувача:

    $value = Cache::flexible('users', [5, 10], function () {
        return DB::table('users')->get();
    });

<a name="retrieve-delete"></a>
#### Отримання даних з подальшим видаленням елемента

Якщо вам потрібно отримати елемент з кеша, а потім видалити цей елемент, ви можете використовувати метод `pull`. Як і в методі `get`, якщо елемент не існує в кеші, то буде повернуто `null`:

    $value = Cache::pull('key');

    $value = Cache::pull('key', 'default');

<a name="storing-items-in-the-cache"></a>
### Збереження елементів у кеші

Ви можете використовувати метод `put` фасаду` Cache` для збереження елементів у кеші:

    Cache::put('key', 'value', $seconds = 10);

Якщо час зберігання не передається методу `put`, то елемент зберігатиметься нескінченно:

    Cache::put('key', 'value');

Замість того щоб передавати кількість секунд як ціле число, ви також можете передати екземпляр `DateTime`, що представляє бажаний час зберігання кешованого елемента:

    Cache::put('key', 'value', now()->addMinutes(10));

<a name="store-if-not-present"></a>
#### Збереження значень за умови їх відсутності

Метод `add` додасть елемент у кеш, тільки якщо він ще не існує в сховищі кеша. Метод поверне `true`, якщо елемент було дійсно додано в кеш. В іншому випадку метод поверне `false`. Метод `add` - це [атомарна операція](https://ru.wikipedia.org/wiki/Атомарная_операция):

    Cache::add('key', 'value', $seconds);

<a name="storing-items-forever"></a>
#### Збереження елементів на постійній основі

Метод `forever` використовується для постійного зберігання елемента в кеші. Оскільки термін дії цих елементів не спливає, то їх необхідно вручну видалити з кеша за допомогою методу `forget`:

    Cache::forever('key', 'value');

> [!NOTE]
> Якщо ви використовуєте драйвер `memcached`, то елементи, які зберігаються «на постійній основі», можуть бути видалені, коли кеш досягне граничного розміру.

<a name="removing-items-from-the-cache"></a>
### Видалення елементів із кешу

Ви можете видалити елементи з кеша за допомогою методу `forget`:

    Cache::forget('key');

Ви також можете видалити елементи, вказавши нульову або від'ємну кількість секунд терміну зберігання:

    Cache::put('key', 'value', 0);

    Cache::put('key', 'value', -5);

Ви можете очистити весь кеш, використовуючи метод `flush`:

    Cache::flush();

> [!WARNING]
> Очищення кеша не враховує ваш налаштований «префікс» кеша і видаляє всі записи з кеша. Уважно враховуйте це під час очищення кешу, який використовується іншими додатками.

<a name="the-cache-helper"></a>
### Глобальний помічник кешу

Крім використання фасаду `Cache`, ви також можете використовувати глобальну функцію `cache` для вилучення і зберігання даних через кеш. Коли функція `cache` викликається з одним строковим аргументом, вона повертає значення переданого ключа:

    $value = cache('key');

Якщо ви передасте масив пар ключ/значення і термін зберігання у функцію, то вона буде зберігати значення в кеші протягом зазначеного часу:

    cache(['key' => 'value'], $seconds);

    cache(['key' => 'value'], now()->addMinutes(10));

Коли функція `cache` викликається без будь-яких аргументів, то вона повертає екземпляр реалізації `Illuminate\Contracts\Cache\Factory`, дозволяючи вам викликати інші методи кешування:

    cache()->remember('users', $seconds, function () {
        return DB::table('users')->get();
    });


> [!NOTE]  
> Під час тестування виклику глобальної функції `cache` ви можете використовувати метод `Cache::shouldReceive` так само, як якби ви [тестували фасад](/docs/{{version}}/mocking#mocking-facades).

<a name="atomic-locks"></a>
## Атомарні блокування

> [!WARNING]
> Щоб використовувати цей функціонал, ваш застосунок має використовувати драйвер кешу `memcached`, `redis`, `dynamodb`, `database`, `file`, або `array` як драйвер кешу за замовчуванням для вашого застосунку. Крім того, всі сервери повинні взаємодіяти з одним і тим же центральним сервером кешування.

<a name="managing-locks"></a>
### Керування блокуваннями

Атомарні блокування дають змогу керувати розподіленими блокуваннями, не турбуючись про умови пріоритетності. Наприклад, [Laravel Forge](https://forge.laravel.com) використовує атомарні блокування, щоб гарантувати, що на сервері одночасно виконується тільки одне віддалене завдання. Ви можете створювати та керувати блокуваннями, використовуючи метод `Cache::lock`:

    use Illuminate\Support\Facades\Cache;

    $lock = Cache::lock('foo', 10);

    if ($lock->get()) {
        // Блокування отримано на 10 секунд ...

        $lock->release();
    }

Метод `get` також приймає замикання. Після виконання замикання Laravel автоматично зніме блокування:

    Cache::lock('foo', 10)->get(function () {
        // Блокування встановлено на 10 секунд і автоматично знімається ...
    });

Якщо блокування недоступне в той момент, коли ви його запитуєте, ви можете вказати Laravel почекати певну кількість секунд. Якщо блокування не може бути отримано протягом зазначеного терміну, то буде викинуто виняток `Illuminate\Contracts\Cache\LockTimeoutException`:

    use Illuminate\Contracts\Cache\LockTimeoutException;

    $lock = Cache::lock('foo', 10);

    try {
        $lock->block(5);

        // Блокування отримано після очікування максимум 5 секунд ...
    } catch (LockTimeoutException $e) {
        // Неможливо отримати блокування ...
    } finally {
        $lock->release();
    }

Наведений вище приклад можна спростити, передавши замикання методу `block`. Коли замикання передається цьому методу, Laravel намагатиметься отримати блокування на зазначену кількість секунд і автоматично зніме блокування, щойно замикання буде виконано:

    Cache::lock('foo', 10)->block(5, function () {
        // Блокування отримано після очікування максимум 5 секунд ...
    });

<a name="managing-locks-across-processes"></a>
### Керування блокуваннями між процесами

Іноді може знадобитися встановити блокування в одному процесі та зняти його в іншому процесі. Наприклад, ви можете отримати блокування під час веб-запиту і захочете зняти блокування наприкінці завдання в черзі, яке запускається цим запитом. У цьому сценарії ви повинні передати «токен ініціатора» з областю дії блокування в завданні в черзі, щоб завдання могло повторно створити примірник блокування з використанням цього токена.

У наведеному нижче прикладі ми відправимо завдання в чергу, якщо блокування буде успішно отримано. Крім того, ми передамо токен ініціатора блокування завданню в черзі за допомогою методу `owner` блокування:

    $podcast = Podcast::find($id);

    $lock = Cache::lock('processing', 120);

    if ($lock->get()) {
        ProcessPodcast::dispatch($podcast, $lock->owner());
    }

У межах завдання `ProcessPodcast` нашого застосунку ми можемо відновити і зняти блокування за допомогою токена ініціатора:

    Cache::restoreLock('processing', $this->owner)->release();

Якщо ви хочете примусово зняти блокування без урахування поточного ініціатора, то ви можете використовувати метод `forceRelease`:

    Cache::lock('processing')->forceRelease();

<a name="adding-custom-cache-drivers"></a>
## Додавання власних драйверів кешу

<a name="writing-the-driver"></a>
### Написання драйвера кешу

Щоб створити власний драйвер кешу, спершу потрібно реалізувати [контракт](/docs/{{version}}/contracts) `Illuminate\Contracts\Cache\Store`. Отже, реалізація кешу MongoDB може виглядати приблизно так:

    <?php

    namespace App\Extensions;

    use Illuminate\Contracts\Cache\Store;

    class MongoStore implements Store
    {
        public function get($key) {}
        public function many(array $keys) {}
        public function put($key, $value, $seconds) {}
        public function putMany(array $values, $seconds) {}
        public function increment($key, $value = 1) {}
        public function decrement($key, $value = 1) {}
        public function forever($key, $value) {}
        public function forget($key) {}
        public function flush() {}
        public function getPrefix() {}
    }

Нам просто потрібно реалізувати кожен із цих методів, використовуючи з'єднання MongoDB. Для прикладу того, як реалізувати кожен із цих методів, погляньте на `Illuminate\Cache\MemcachedStore` у [вихідному коді фреймворка Laravel](https://github.com/laravel/framework). Як тільки наша реалізація буде завершена, ми можемо завершити реєстрацію свого драйвера, викликавши метод `extend` фасаду `Cache`:

    Cache::extend('mongo', function (Application $app) {
        return Cache::repository(new MongoStore);
    });

> [!NOTE]  
> Якщо вам цікаво, де розмістити свій власний код драйвера кешу, то ви можете створити простір імен `Extensions` у своєму каталозі `app`. Однак майте на увазі, що Laravel не має жорсткої структури програми, і ви можете організувати свій додаток відповідно до своїх уподобань.

<a name="registering-the-driver"></a>
### Реєстрація драйвера кешу

Щоб зареєструвати свій драйвер кешу в Laravel, ми будемо використовувати метод `extend` фасаду `Cache`. Оскільки інші постачальники служб можуть спробувати прочитати кешовані значення в рамках свого методу `boot`, ми зареєструємо свій драйвер у замиканні `booting`. Використовуючи замикання `booting`, ми можемо гарантувати, що наш драйвер зареєстрований безпосередньо перед тим, як метод `boot` викликається постачальниками служб нашої програми, і після того, як метод `register` викликається для всіх постачальників служб. Ми зареєструємо наше замикання `booting` у методі `register` класу `App\Providers\AppServiceProvider` нашого додатка:

    <?php

    namespace App\Providers;

    use App\Extensions\MongoStore;
    use Illuminate\Contracts\Foundation\Application;
    use Illuminate\Support\Facades\Cache;
    use Illuminate\Support\ServiceProvider;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Реєстрація будь-яких служб додатка.
         */
        public function register(): void
        {
            $this->app->booting(function () {
                Cache::extend('mongo', function (Application $app) {
                    return Cache::repository(new MongoStore);
                });
            });
        }

        /**
         * Завантаження будь-яких служб програми.
         */
        public function boot(): void
        {
            // ...
        }
    }

Першим аргументом, переданим методу `extend`, є ім'я драйвера. Воно відповідатиме вашому параметру `driver` у файлі конфігурації `config/cache.php`. Другий аргумент - це замикання, яке має повертати екземпляр `Illuminate\Cache\Repository`. Замикання буде передано екземпляру `$app`, який є екземпляром [контейнера служб](/docs/{{version}}}/container).

Після реєстрації розширення поновіть змінну середовища `CACHE_STORE` або опцію `default` у файлі конфігурації вашого додатка `config/cache.php`, вказавши ім'я вашого розширення.

<a name="events"></a>
## Події

Щоб виконати код під час кожної операції з кешем, ви можете прослуховувати [події](/docs/{{version}}{{version}}/events), що запускаються кешем:

| Найменування події                  |
| -------------------------------------- |
| `Illuminate\Cache\Events\CacheHit`     |
| `Illuminate\Cache\Events\CacheMissed`  |
| `Illuminate\Cache\Events\KeyForgotten` |
| `Illuminate\Cache\Events\KeyWritten`   |

Щоб підвищити продуктивність, ви можете вимкнути події кешування, встановивши для параметра конфігурації `events` значення `false` для цього сховища кешу у файлі конфігурації `config/cache.php` вашого застосунку:

```php
'database' => [
    'driver' => 'database',
    // ...
    'events' => false,
],
```
