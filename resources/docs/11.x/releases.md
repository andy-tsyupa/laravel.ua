# Примітки до релізу

<a name="versioning-scheme"></a>
## Схема версій

Laravel та інші його власні пакети дотримуються [семантичного версіонування](https://semver.org/lang/ru/). Мажорні релізи фреймворка випускаються щороку (приблизно в першому кварталі), тоді як мінорні та патч-релізи можуть випускатися щотижня. Мінорні та патч-релізи **ніколи** не повинні містити критичних змін.

Посилаючись на фреймворк Laravel або його компоненти з вашого додатка або пакета, ви завжди повинні використовувати обмеження версії `^11.0`, оскільки мажорні релізи Laravel справді включають критичні зміни. Однак ми завжди прагнемо до того, щоб ви могли виконати оновлення до нової мажорної версії протягом дня або менше.

<a name="exceptions"></a>
### Винятки

<a name="named-arguments"></a>
#### Іменовані аргументи

[Іменовані аргументи](https://www.php.net/manual/ru/functions.arguments.php#functions.named-arguments) не підпадають під правила зворотної сумісності Laravel. За необхідності ми можемо перейменувати аргументи функції, щоб поліпшити кодову базу Laravel. Тому використовувати іменовані аргументи під час виклику методів Laravel слід обережно і з розумінням того, що їхні імена можуть змінитися в майбутньому.

<a name="support-policy"></a>
## Політика підтримки

Для всіх випусків Laravel виправлення помилок надаються протягом 18 місяців, а виправлення безпеки - протягом 2 років. Для всіх додаткових бібліотек, включно з Lumen, тільки останній основний випуск отримує виправлення помилок. Крім того, ознайомтеся з версіями баз даних, які [підтримує Laravel](/docs/{{version}}/database#introduction).

<div id="support-policy">

| Версія | PHP (*)   | Дата релізу         | Виправлення помилок до | Виправлення безпеки до |
| ------ | --------- | ------------------- | --------------------- | --------------------------- |
| 9 ¹    | 8.0 - 8.2 | 8 лютого 2022      | 8 серпень 2023        | 6 лютого 2024              |
| 10 ²   | 8.1 - 8.3 | 14 лютого 2023     | 6 серпень 2024        | 4 лютого 2025              |
| 11     | 8.2 - 8.3 | 12 березень 2024   | 3 вересень 2025       | 12 березень 2026           |
| 12     | 8.2 - 8.3 | Q1 2025            | Q3 2026               | Q1 2027                    |

</div>

<div class="version-colors">
    <div class="end-of-life">
        <div class="color-box"></div>
        <div>¹ Закінчення підтримки</div>
    </div>
    <div class="security-fixes">
        <div class="color-box"></div>
        <div>² Тільки виправлення безпеки</div>
    </div>
</div>

(*) Підтримувані версії PHP

<a name="laravel-11"></a>
## Laravel 11

Laravel 11 продовжує поліпшення, зроблені в Laravel 10.x, представляючи оптимізовану структуру додатка, обмеження швидкості на секунду, маршрутизацію працездатності, плавну ротацію ключів шифрування, поліпшення тестування черг, поштовий транспорт [Resend](https://resend.com), інтеграція валідатора Prompt, нові команди Artisan і багато іншого. Крім того, було представлено Laravel Reverb, власний масштабований сервер WebSocket, що забезпечує надійні можливості роботи в реальному часі для ваших додатків.

<a name="php-8"></a>
### PHP 8.2

Для Laravel 11.x потрібна мінімальна версія PHP 8.2.

<a name="structure"></a>
### Оптимізована структура додатка

_Оптимізовану структуру додатка Laravel розробили [Тейлор Отвелл (Taylor Otwell)](https://github.com/taylorotwell) і [Нуно Мадуро (Nuno Maduro)](https://github.com/nunomaduro)_.

Laravel 11 представляє спрощену структуру застосунків для **нових** застосунків Laravel, що не вимагає внесення будь-яких змін до наявних застосунків. Нова структура застосунку покликана забезпечити компактніший і сучасніший інтерфейс, зберігаючи водночас багато концепцій, з якими розробники Laravel уже знайомі. Нижче ми обговоримо основні моменти нової структури програми Laravel.

#### Файл початкового завантаження програми

Файл `bootstrap/app.php` було оновлено як файл конфігурації програми, орієнтований на код. З цього файлу ви тепер можете налаштувати маршрутизацію вашого додатка, посередників (middleware), постачальників послуг, обробку винятків і багато іншого. Цей файл об'єднує різні високорівневі налаштування поведінки програми, які раніше були розкидані по файловій структурі вашого додатка:

```php
return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        commands: __DIR__.'/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {
        //
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();
```

<a name="service-providers"></a>
#### Постачальники послуг

Замість структури додатка Laravel за замовчуванням, що містить п'ять постачальників послуг, Laravel 11 включає тільки один `AppServiceProvider`. Функціональність попередніх постачальників послуг була включена в `bootstrap/app.php`, автоматично обробляється платформою або може бути розміщена в `AppServiceProvider` вашого додатка.

Наприклад, виявлення подій тепер увімкнено за замовчуванням, що значною мірою усуває необхідність ручної реєстрації подій та їхніх прослуховувачів. Однак якщо вам необхідно зареєструвати події вручну, ви можете просто зробити це в `AppServiceProvider`. Аналогічно, прив'язки моделі маршруту або шлюзи авторизації, які ви, можливо, раніше зареєстрували в `AuthServiceProvider`, також можуть бути зареєстровані в `AppServiceProvider`.

<a name="opt-in-routing"></a>
#### Узгодження API та широкомовна маршрутизація

Файли маршрутів `api.php` і `channels.php` більше не присутні за замовчуванням, оскільки багатьом програмам ці файли не потрібні. Замість цього їх можна створити за допомогою простих команд Artisan:

```shell
php artisan install:api

php artisan install:broadcasting
```

<a name="middleware"></a>
#### Посередники (Middleware)

Раніше нові додатки Laravel включали дев'ять посередників. Ці посередники виконували різні завдання, як-от аутентифікація запитів, обрізка вхідних рядків і перевірка токенів CSRF.

У Laravel 11 ці посередники були перенесені в сам фреймворк, щоб воно не збільшувало обсяг структури вашого додатка. В інфраструктуру додано нові методи для налаштування поведінки цих посередників, які можна викликати з файлу `bootstrap/app.php` вашого додатка:

```php
->withMiddleware(function (Middleware $middleware) {
    $middleware->validateCsrfTokens(
        except: ['stripe/*']
    );

    $middleware->web(append: [
        EnsureUserIsSubscribed::class,
    ])
})
```

Оскільки все проміжне програмне забезпечення можна легко налаштувати за допомогою файлу `bootstrap/app.php` вашого додатка, необхідність в окремому класі «Kernel» HTTP було усунуто.

<a name="scheduling"></a>
#### Планування (Scheduling)

Використовуючи новий фасад `Schedule`, заплановані завдання тепер можуть бути визначені безпосередньо у файлі `routes/console.php` вашого додатка, що усуває необхідність в окремому класі «Kernel» консолі:

```php
use Illuminate\Support\Facades\Schedule;

Schedule::command('emails:send')->daily();
```

<a name="exception-handling"></a>
#### Обробка винятків

Як маршрутизація і посередники, обробку винятків тепер можна налаштувати з файлу `bootstrap/app.php` вашого застосунку замість окремого класу обробника винятків, що скорочує загальну кількість файлів, включених у новий застосунок Laravel:

```php
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->dontReport(MissedFlightException::class);

    $exceptions->report(function (InvalidOrderException $e) {
        // ...
    });
})
```

<a name="base-controller-class"></a>
#### Базовий клас `Controller`

Базовий контролер, включений у нові додатки Laravel, було спрощено. Він більше не розширює внутрішній клас `Controller` Laravel, а трейти `AuthorizesRequests` і `ValidatesRequests` було видалено, оскільки за бажання їх можна включити до окремих контролерів вашої програми:

    <?php

    namespace App\Http\Controllers;

    abstract class Controller
    {
        //
    }

<a name="application-defaults"></a>
#### Application Defaults

За замовчуванням нові додатки Laravel використовують SQLite для зберігання бази даних, а також драйвер `database` для сеансу, кешу та черги Laravel. Це дає вам змогу розпочати розробку одразу після створення нового додатка Laravel, без необхідності встановлювати додаткове програмне забезпечення або створювати додаткові міграції бази даних.

Крім того, з часом драйвери `database` для цих сервісів Laravel стали досить надійними для виробничого використання в багатьох контекстах додатків; тому вони являють собою розумний і уніфікований вибір як для локального, так і для виробничого застосування.

<a name="reverb"></a>
### Laravel Reverb

_Laravel Reverb було розроблено [Джо Діксоном (Joe Dixon)](https://github.com/joedixon)_

[Laravel Reverb](https://reverb.laravel.com) забезпечує неймовірно швидкий і масштабований зв'язок через WebSocket у реальному часі безпосередньо у вашому додатку Laravel і забезпечує плавну інтеграцію з наявним набором інструментів трансляції подій Laravel, такими як Laravel Echo.

```shell
php artisan reverb:start
```

Крім того, Reverb підтримує горизонтальне масштабування за допомогою можливостей публікації/передплати Redis, що дає вам змогу розподіляти трафік WebSocket між декількома внутрішніми серверами Reverb, які підтримують один затребуваний застосунок.

Для отримання додаткової інформації про Laravel Reverb зверніться до повної [документації по Reverb](/docs/{{version}}/reverb).

<a name="rate-limiting"></a>
### Обмеження посекундної швидкості

_Посекундне обмеження швидкості було надано [Тімом Макдональдом (Tim MacDonald)](https://github.com/timacdonald)_.

Laravel тепер підтримує «посекундне» обмеження швидкості для всіх обмежувачів швидкості, включно з обмеженнями для HTTP-запитів і завдань у черзі. Раніше обмежувачі швидкості Laravel були обмежені похвилинною деталізацією:

```php
RateLimiter::for('invoices', function (Request $request) {
    return Limit::perSecond(1);
});
```

Для отримання додаткової інформації про обмеження швидкості в Laravel ознайомтеся з [документацією з обмеження швидкості](/docs/{{version}}/routing#rate-limiting).

<a name="health"></a>
### Маршрутизація здоров'я

_Маршрутизацію працездатності надав [Тейлор Отвелл (Taylor Otwell)](https://github.com/taylorotwell)_.

Нові додатки Laravel 11 включають директиву маршрутизації `health`, яка інструктує Laravel визначити просту кінцеву точку перевірки працездатності, яка може бути викликана сторонніми службами моніторингу працездатності додатків або системами оркестрації, такими як Kubernetes. За замовчуванням цей маршрут обслуговується за адресою `/up`:

```php
->withRouting(
    web: __DIR__.'/../routes/web.php',
    commands: __DIR__.'/../routes/console.php',
    health: '/up',
)
```

Коли HTTP-запити надсилаються за цим маршрутом, Laravel також надсилає подію `DiagnosingHealth`, яка дає змогу вам виконувати додаткові перевірки працездатності, що стосуються вашого додатка.

<a name="encryption"></a>
### Граціозна ротація ключів шифрування

Витончену ротацію ключів шифрування надав [Тейлор Отвелл (Taylor Otwell)](https://github.com/taylorotwell)_.

Оскільки Laravel шифрує всі файли cookie, включно з файлами cookie сеансу вашого застосунку, по суті, кожен запит до застосунку Laravel заснований на шифруванні. Однак через це зміна ключа шифрування вашого додатка призведе до виходу всіх користувачів з вашого додатка. Крім того, розшифровка даних, зашифрованих попереднім ключем шифрування, стає неможливою.

Laravel 11 дозволяє вам визначати попередні ключі шифрування вашої програми у вигляді списку, розділеного комами, через змінну середовища `APP_PREVIOUS_KEYS`.

При шифруванні значень Laravel завжди буде використовувати «поточний» ключ шифрування, який знаходиться у змінній середовища `APP_KEY`. Під час розшифрування значень Laravel спочатку спробує використати поточний ключ. Якщо розшифрування з використанням поточного ключа не вдалося, Laravel спробує використати всі попередні ключі, поки один із ключів не зможе розшифрувати значення.

Такий підхід до коректного дешифрування дозволяє користувачам продовжувати користуватися вашим додатком безперервно, навіть якщо ваш ключ шифрування буде замінено.

Додаткову інформацію про шифрування в Laravel можна знайти в [документації з шифрування](/docs/{{version}}/encryption).

<a name="automatic-password-rehashing"></a>
### Автоматична зміна (rehashing) пароля

_Автоматичну зміну (rehashing) пароля було надано [Стівеном Ріс-Картером (Stephen Rees-Carter)](https://github.com/valorin)_.

Алгоритм хешування паролів у Laravel за замовчуванням - bcrypt. «Робочий коефіцієнт» для хешів bcrypt можна налаштувати за допомогою файлу конфігурації `config/hashing.php` або змінної середовища `BCRYPT_ROUNDS`.

Зазвичай робочий коефіцієнт bcrypt слід збільшувати з плином часу в міру збільшення обчислювальної потужності процесора/графічного процесора. Якщо ви збільшите робочий коефіцієнт bcrypt для свого додатка, Laravel тепер буде коректно й автоматично перехеширувати паролі користувачів, коли користувачі проходять аутентифікацію у вашому додатку.

<a name="prompt-validation"></a>
### Валідатор Prompt

_Інтеграцію валідатора Prompt надав [Андреа Марко Сарторі (Andrea Marco Sartori)](https://github.com/cerbero90)_.

[Laravel Prompts](/docs/{{version}}}/prompts) - це пакет PHP для додавання гарних і зручних форм до ваших застосунків командного рядка з функціями браузера, включно з текстом-заповнювачем і перевіркою.

Laravel Prompts підтримує перевірку введення через замикання:

```php
$name = text(
    label: 'What is your name?',
    validate: fn (string $value) => match (true) {
        strlen($value) < 3 => 'The name must be at least 3 characters.',
        strlen($value) > 255 => 'The name must not exceed 255 characters.',
        default => null
    }
);
```

Однак це може стати важким при роботі з багатьма вхідними даними або складними сценаріями перевірки. Таким чином, у Laravel 11 ви можете використовувати всю міць [валідатора](/docs/{{version}}}/validation) Laravel під час перевірки введення підказки:

```php
$name = text('What is your name?', validate: [
    'name' => 'required|min:3|max:255',
]);
```

<a name="queue-interaction-testing"></a>
### Тестування взаємодії з чергою

_Тестування взаємодії з чергою було надано [Тейлор Отвелл (Taylor Otwell)](https://github.com/taylorotwell)_.

Раніше спроба перевірити, чи було завдання в черзі випущене, видалене або завершилося збоєм вручну, була обтяжливою і вимагала визначення користувацьких підробок і заглушок черги. Однак у Laravel 11 ви можете легко протестувати ці взаємодії з чергою, використовуючи метод `withFakeQueueInteractions`:

```php
use App\Jobs\ProcessPodcast;

$job = (new ProcessPodcast)->withFakeQueueInteractions();

$job->handle();

$job->assertReleased(delay: 30);
```

Додаткову інформацію про тестування завдань у черзі див. у [документації щодо черги](/docs/{{version}}/queues#testing).

<a name="new-artisan-commands"></a>
### Нові команди Artisan

_Команди Artisan для створення класів були надані [Тейлор Отвелл (Taylor Otwell)](https://github.com/taylorotwell)_.

Було додано нові команди Artisan, що дають змогу швидко створювати класи, перерахування, інтерфейси та особливості:

```shell
php artisan make:class
php artisan make:enum
php artisan make:interface
php artisan make:trait
```

<a name="model-cast-improvements"></a>
### Поліпшення приведення моделей

_Покращення приведення моделей було внесено [Нуно Мадуро (Nuno Maduro)](https://github.com/nunomaduro)_.

Laravel 11 підтримує визначення приведення моделі з використанням методу, а не властивості. Це дає змогу спростити і плавно визначити приведення типів, особливо при використанні приведення з аргументами:

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'options' => AsCollection::using(OptionCollection::class),
                      // AsEncryptedCollection::using(OptionCollection::class),
                      // AsEnumArrayObject::using(OptionEnum::class),
                      // AsEnumCollection::using(OptionEnum::class),
        ];
    }

Для отримання додаткової інформації про приведення атрибутів ознайомтеся з [документацією Eloquent](/docs/{{version}}/eloquent-mutators#attribute-casting).

<a name="the-once-function"></a>
### Функція `once`

_Помічник `once` був наданий [Тейлор Отвелл (Taylor Otwell)](https://github.com/taylorotwell)_ і _[Нуно Мадуро (Nuno Maduro)](https://github.com/nunomaduro)_.

Допоміжна функція `once` виконує заданий зворотний виклик і кешує результат у пам'яті на час виконання запиту. Будь-які наступні виклики функції `once` з тим самим зворотним викликом повертатимуть раніше кешований результат:

    function random(): int
    {
        return once(function () {
            return random_int(1, 1000);
        });
    }

    random(); // 123
    random(); // 123 (cached result)
    random(); // 123 (cached result)

Додаткову інформацію про помічника `once` можна знайти в [документації щодо помічників](/docs/{{version}}/helpers#method-once).

<a name="database-performance"></a>
### Покращена продуктивність під час тестування з базами даних у пам'яті.

_Покращення продуктивності тестування баз даних у пам'яті було надано [Андерсом Дженбо (Anders Jenbo)](https://github.com/AJenbo)_

Laravel 11 пропонує значний приріст швидкості при використанні бази даних `:memory:` SQLite під час тестування. Для досягнення цієї мети Laravel тепер підтримує посилання на об'єкт PDO PHP і повторно використовує його при різних з'єднаннях, часто скорочуючи загальний час виконання тесту вдвічі.

<a name="mariadb"></a>
### Покращена підтримка MariaDB.

_Покращену підтримку MariaDB надали [Йонас Штауденмейр (Jonas Staudenmeir)](https://github.com/staudenmeir) і [Юліус Кіекбуш (Julius Kiekbusch)](https://github.com/Jubeki)_.

Laravel 11 включає поліпшену підтримку MariaDB. У попередніх випусках Laravel ви могли використовувати MariaDB через драйвер MySQL Laravel. Однак Laravel 11 тепер включає спеціальний драйвер MariaDB, який забезпечує кращі налаштування за замовчуванням для цієї системи баз даних.

Додаткову інформацію про драйвери бази даних Laravel можна знайти в [документації по базі даних](/docs/{{version}}/database).

<a name="inspecting-database"></a>
### Перевірка баз даних і поліпшені операції зі схемою

_Покращення операцій зі схемою та перевірку бази даних надано [Хафезом Дівандарі (Hafez Divandari)](https://github.com/hafezdivandari)_

Laravel 11 надає додаткові методи роботи та перевірки схеми бази даних, включно з вбудованою зміною, перейменуванням і видаленням стовпців. Крім того, надаються розширені просторові типи, імена схем, відмінні від стандартних, і власні методи схеми для управління таблицями, поданнями, стовпчиками, індексами та зовнішніми ключами:

    use Illuminate\Support\Facades\Schema;

    $tables = Schema::getTables();
    $views = Schema::getViews();
    $columns = Schema::getColumns('users');
    $indexes = Schema::getIndexes('users');
    $foreignKeys = Schema::getForeignKeys('users');
