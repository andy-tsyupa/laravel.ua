# Представлення

- [Вступ](#introduction)
    - [Написання представлень у React / Vue](#writing-views-in-react-or-vue)
- [Створення та рендеринг подань](#creating-and-rendering-views)
    - [Вкладені каталоги представлень](#nested-view-directories)
    - [Створення першого доступного подання](#creating-the-first-available-view)
    - [Визначення того, чи існує подання](#determining-if-a-view-exists)
- [Передача даних у подання](#passing-data-to-views)
    - [Спільний доступ до даних з усіма поданнями](#sharing-data-with-all-views)
- [Переглянути композиторів](#view-composers)
    - [Переглянути творців](#view-creators)
- [Оптимізація переглядів](#optimizing-views)

<a name="introduction"></a>
## Вступ

Звичайно, непрактично повертати цілі рядки HTML-документів безпосередньо з маршрутів і контролерів. На щастя, подання надають зручний спосіб розмістити весь наш HTML в окремих файлах.

Представлення відокремлюють логіку вашого контролера/додатку від логіки вашого представлення і зберігаються в каталозі `resources/views`. При використанні Laravel, шаблони представлень зазвичай пишуться за допомогою [Мова шаблонів леза](/docs/{{version}}/blade). Простий погляд може виглядати приблизно так:

```blade
<!-- Представлення зберігається в resources/views/greeting.blade.php -->

<html>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>
```

Оскільки це подання зберігається за адресою `resources/views/greeting.blade.php`, ми можемо повернути його за допомогою глобального хелпера `view` ось так:

    Route::get('/', function () {
        return view('greeting', ['name' => 'James']);
    });

> [!NOTE]  
> Шукаєте більше інформації про те, як писати шаблони Blade? Ознайомтеся з повною версією [Документація до леза](/docs/{{version}}/blade) щоб почати.

<a name="writing-views-in-react-or-vue"></a>
### Написання представлень у React / Vue

Замість того, щоб писати свої фронтенд-шаблони на PHP через Blade, багато розробників почали надавати перевагу написанню шаблонів за допомогою React або Vue. Laravel робить це безболісним завдяки [Inertia](https://inertiajs.com/) бібліотека, яка дозволяє легко зв'язати ваш фронтенд React / Vue з бекендом Laravel без типових складнощів при створенні SPA.

Наш вітерець і струмінь [стартові набори](/docs/{{version}}/starter-kits) дасть вам чудову відправну точку для створення вашого наступного додатку на Laravel на основі Inertia. Крім того, в розділі [Laravel Bootcamp](https://bootcamp.laravel.com) надає повну демонстрацію створення Laravel-додатків на основі Inertia, включаючи приклади на Vue та React.

<a name="creating-and-rendering-views"></a>
## Створення та рендеринг подань

Ви можете створити подання, розмістивши файл з розширенням `.blade.php` у директорії `resources/views` вашого додатку або за допомогою команди Artisan `make:view`:

```shell
php artisan make:view greeting
```

Розширення `.blade.php` повідомляє фреймворку, що файл містить [Blade шаблони](/docs/{{version}}/blade). Шаблони Blade містять HTML, а також директиви Blade, які дозволяють легко повторювати значення, створювати оператори «if», ітерації над даними тощо.

Після того, як ви створили подання, ви можете повернути його з одного з маршрутів або контролерів вашої програми за допомогою глобального помічника `view`:

    Route::get('/', function () {
        return view('greeting', ['name' => 'James']);
    });

Вигляд також можна повернути за допомогою фасаду `View`:

    use Illuminate\Support\Facades\View;

    return View::make('greeting', ['name' => 'James']);

Як ви можете бачити, перший аргумент, переданий допоміжному засобу `view`, відповідає імені файлу подання у каталозі `resources/views`. Другий аргумент - це масив даних, які слід зробити доступними для подання. У цьому випадку ми передаємо змінну `name`, яка відображається у поданні за допомогою [Синтаксис леза](/docs/{{version}}/blade).

<a name="nested-view-directories"></a>
### Вкладені каталоги представлень

Подання також можуть бути вкладені у підкаталоги каталогу `resources/views`. Для посилання на вкладені подання можна використовувати позначення «крапка». Наприклад, якщо ваше подання зберігається у `resources/views/admin/profile.blade.php`, ви можете повернути його з одного з маршрутів/контролерів вашого додатку таким чином:

    return view('admin.profile', $data);

> [!WARNING]  
> Назви каталогів перегляду не повинні містити символ `.`.

<a name="creating-the-first-available-view"></a>
### Створення першого доступного подання

За допомогою методу `first` фасаду `View` ви можете створити перше подання, яке існує у заданому масиві подань. Це може бути корисно, якщо ваша програма або пакет дозволяє змінювати або перезаписувати подання:

    use Illuminate\Support\Facades\View;

    return View::first(['custom.admin', 'admin'], $data);

<a name="determining-if-a-view-exists"></a>
### Визначення того, чи існує подання

Якщо вам потрібно визначити, чи існує вид, ви можете використати фасад `View`. Метод `exists` поверне значення `true`, якщо вид існує:

    use Illuminate\Support\Facades\View;

    if (View::exists('admin.profile')) {
        // ...
    }

<a name="passing-data-to-views"></a>
## Передача даних у подання

Як ви бачили у попередніх прикладах, ви можете передати масив даних у подання, щоб зробити ці дані доступними для подання:

    return view('greetings', ['name' => 'Victoria']);

При передачі інформації в такий спосіб дані повинні бути масивом з парами ключ/значення. Після передачі даних до подання ви можете отримати доступ до кожного значення у вашому поданні за допомогою ключів даних, наприклад, `<?php echo $name; ?>`.

Як альтернативу передачі повного масиву даних у допоміжну функцію `view`, ви можете використовувати метод `with` для додавання окремих фрагментів даних до представлення. Метод `with` повертає екземпляр об'єкта представлення, щоб ви могли продовжити ланцюжок методів перед поверненням представлення:

    return view('greeting')
                ->with('name', 'Victoria')
                ->with('occupation', 'Astronaut');

<a name="sharing-data-with-all-views"></a>
### Спільний доступ до даних з усіма поданнями

Іноді вам може знадобитися поділитися даними з усіма поданнями, які відображаються вашим додатком. Ви можете зробити це за допомогою методу `share` фасаду `View`. Зазвичай, вам слід розміщувати виклики методу `share` у методі `boot` постачальника послуг. Ви можете додати їх до класу `App\Providers\AppServiceProvider` або згенерувати окремого постачальника послуг для їх розміщення:

    <?php

    namespace App\Providers;

    use Illuminate\Support\Facades\View;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Реєструйте будь-які сервіси додатків.
         */
        public function register(): void
        {
            // ...
        }

        /**
         * Завантажуйте будь-які сервіси додатків.
         */
        public function boot(): void
        {
            View::share('key', 'value');
        }
    }

<a name="view-composers"></a>
## Переглянути композиторів

Композитори представлень - це функції зворотного виклику або методи класу, які викликаються при рендерингу представлення. Якщо у вас є дані, які ви хочете прив'язувати до подання щоразу, коли це подання відображається, композитор подання може допомогти вам організувати цю логіку в єдиному місці. Композитори представлень можуть виявитися особливо корисними, якщо те саме представлення повертається декількома маршрутами або контролерами у вашому додатку і завжди потребує певного фрагмента даних.

Зазвичай, композитори перегляду будуть зареєстровані в одному з ваших додатків [постачальники послуг](/docs/{{version}}/providers). У цьому прикладі ми припустимо, що `App\Providers\AppServiceProvider` буде містити цю логіку.

Ми використаємо метод `composer` фасаду `View` для реєстрації композитора вигляду. У Laravel не передбачено каталогу за замовчуванням для класів-композиторів, тому ви можете організувати їх так, як вам заманеться. Наприклад, ви можете створити каталог `app/View/Composers` для розміщення усіх композиторів вигляду вашої програми:

    <?php

    namespace App\Providers;

    use App\View\Composers\ProfileComposer;
    use Illuminate\Support\Facades;
    use Illuminate\Support\ServiceProvider;
    use Illuminate\View\View;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Реєструйте будь-які сервіси додатків.
         */
        public function register(): void
        {
            // ...
        }

        /**
         * Завантажуйте будь-які сервіси додатків.
         */
        public function boot(): void
        {
            // Використовуючи класові композитори...
            Facades\View::composer('profile', ProfileComposer::class);

            // Використовуючи композитори, засновані на замиканні...
            Facades\View::composer('welcome', function (View $view) {
                // ...
            });

            Facades\View::composer('dashboard', function (View $view) {
                // ...
            });
        }
    }

Тепер, коли ми зареєстрували композитор, метод `compose` класу `App\View\Composers\ProfileComposer` буде виконуватися кожного разу, коли рендериться подання `profile`. Давайте розглянемо приклад класу композитора:

    <?php

    namespace App\View\Composers;

    use App\Repositories\UserRepository;
    use Illuminate\View\View;

    class ProfileComposer
    {
        /**
         * Створіть новий профіль композитора.
         */
        public function __construct(
            protected UserRepository $users,
        ) {}

        /**
         * Прив'яжіть дані до подання.
         */
        public function compose(View $view): void
        {
            $view->with('count', $this->users->count());
        }
    }

Як ви можете бачити, всі композитори перегляду вирішуються за допомогою [сервісний контейнер](/docs/{{version}}/container), тож ви можете підказати будь-які залежності, які вам потрібні у конструкторі композитора.

<a name="attaching-a-composer-to-multiple-views"></a>
#### Приєднання композитора до кількох подань

Ви можете приєднати композитор подання до декількох подань одночасно, передавши масив подань як перший аргумент методу `composer`:

    use App\Views\Composers\MultiComposer;
    use Illuminate\Support\Facades\View;

    View::composer(
        ['profile', 'dashboard'],
        MultiComposer::class
    );

Метод `composer` також приймає символ `*` як шаблон, що дозволяє додавати композитора до всіх подань:

    use Illuminate\Support\Facades;
    use Illuminate\View\View;

    Facades\View::composer('*', function (View $view) {
        // ...
    });

<a name="view-creators"></a>
### Переглянути творців

«Творці» подань дуже схожі на композиторів подань, але вони виконуються одразу після того, як подання буде створено, а не чекають, доки подання не буде відрендерено. Щоб зареєструвати творця подання, використовуйте метод `creator`:

    use App\View\Creators\ProfileCreator;
    use Illuminate\Support\Facades\View;

    View::creator('profile', ProfileCreator::class);

<a name="optimizing-views"></a>
## Оптимізація переглядів

За замовчуванням, подання шаблону Blade компілюються на вимогу. При виконанні запиту, який рендерить подання, Laravel визначає, чи існує скомпільована версія подання. Якщо файл існує, Laravel визначить, чи некомпільоване подання було змінено пізніше, ніж скомпільоване. Якщо скомпільоване подання або не існує, або некомпільоване подання було змінено, Laravel перекомпілює подання.

Компіляція представлень під час запиту може мати невеликий негативний вплив на продуктивність, тому Laravel надає команду `view:cache` Artisan для попередньої компіляції всіх представлень, що використовуються вашим додатком. Для підвищення продуктивності ви можете запустити цю команду як частину процесу розгортання:

```shell
php artisan view:cache
```

Ви можете скористатися командою `view:clear` для очищення кешу перегляду:

```shell
php artisan view:clear
```
